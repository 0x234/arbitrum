// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package rollup

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = abi.U256
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// ArbRollupABI is the input ABI used to generate the binding from.
const ArbRollupABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"logsAccHash\",\"type\":\"bytes32\"}],\"name\":\"ConfirmedAssertion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[7]\",\"name\":\"fields\",\"type\":\"bytes32[7]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pendingCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"importedMessageCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[2]\",\"name\":\"timeBoundsBlocks\",\"type\":\"uint128[2]\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"numArbGas\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"numSteps\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didInboxInsn\",\"type\":\"bool\"}],\"name\":\"RollupAsserted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengeContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"}],\"name\":\"RollupChallengeCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asserter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"challengeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengeContract\",\"type\":\"address\"}],\"name\":\"RollupChallengeStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"initVMHash\",\"type\":\"bytes32\"}],\"name\":\"RollupCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"RollupPruned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupStakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"toNodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupStakeMoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"RollupStakeRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"stakerLocations\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedDeadlineStakersSnapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"latestConfirmed\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedLatestConfirmedSnapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedNodeExistsSnapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"location1\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"location2\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedTwoStakersSnapshot\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeFactory\",\"outputs\":[{\"internalType\":\"contractIChallengeFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"challengeNodeData\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"branch\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"vmProtoStateHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"stakerAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"stakerProofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakerProofOffsets\",\"type\":\"uint256[]\"}],\"name\":\"confirmInvalid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"challengeNodeData\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"branch\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"vmProtoStateHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"snapshotIdx\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"stakerLocations\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"stakerProofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakerProofOffsets\",\"type\":\"uint256[]\"}],\"name\":\"confirmInvalidFromSnapshot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_messages\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"logsAcc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vmProtoStateHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"stakerAddresses\",\"type\":\"address[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"stakerProofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakerProofOffsets\",\"type\":\"uint256[]\"}],\"name\":\"confirmValid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_messages\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"logsAcc\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"vmProtoStateHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"snapshotIdx\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"stakerLocations\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"stakerProofs\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakerProofOffsets\",\"type\":\"uint256[]\"}],\"name\":\"confirmValidFromSnapshot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getMySnapshot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStakeRequired\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalInbox\",\"outputs\":[{\"internalType\":\"contractIGlobalPendingInbox\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_vmState\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"_gracePeriodTicks\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_arbGasSpeedLimitPerTick\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"_maxExecutionSteps\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"_stakeRequirement\",\"type\":\"uint128\"},{\"internalType\":\"addresspayable\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_challengeFactoryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_globalInboxAddress\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakerAddress\",\"type\":\"address\"}],\"name\":\"isStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"isValidLeaf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestConfirmed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[9]\",\"name\":\"_fields\",\"type\":\"bytes32[9]\"},{\"internalType\":\"uint256\",\"name\":\"_beforePendingCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_prevDeadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_prevChildType\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"_numSteps\",\"type\":\"uint64\"},{\"internalType\":\"uint128[2]\",\"name\":\"_timeBoundsBlocks\",\"type\":\"uint128[2]\"},{\"internalType\":\"uint256\",\"name\":\"_importedMessageCount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_didInboxInsn\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"_numArbGas\",\"type\":\"uint64\"},{\"internalType\":\"bytes32[]\",\"name\":\"_stakerProof\",\"type\":\"bytes32[]\"}],\"name\":\"makeAssertion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof1\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof2\",\"type\":\"bytes32[]\"}],\"name\":\"moveStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof1\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof2\",\"type\":\"bytes32[]\"}],\"name\":\"placeStake\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"from\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"leafProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"latestConfirmedProof\",\"type\":\"bytes32[]\"}],\"name\":\"pruneLeaf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"recoverStakeConfirmed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"latestConfirmedProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"stakerProof\",\"type\":\"bytes32[]\"}],\"name\":\"recoverStakeMooted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"recoverStakeOld\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"stakerAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"disputableNodeHashVal\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"childType\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"vmProtoStateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"recoverStakePassedDeadline\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resolveChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"beforeDeadlineAddrs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"atOrAfterDeadlineAddrs\",\"type\":\"address[]\"}],\"name\":\"snapshotDeadlineStakers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"snapshotLatestConfirmed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"snapshotLeafNodeExists\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"snapshotStakerNodeExists\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr2\",\"type\":\"address\"}],\"name\":\"snapshotTwoStakers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"asserterAddress\",\"type\":\"address\"},{\"internalType\":\"addresspayable\",\"name\":\"challengerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"prevNode\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"stakerNodeTypes\",\"type\":\"uint256[2]\"},{\"internalType\":\"bytes32[2]\",\"name\":\"vmProtoHashes\",\"type\":\"bytes32[2]\"},{\"internalType\":\"bytes32[]\",\"name\":\"asserterProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"challengerProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"asserterNodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"challengerDataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"challengerPeriodTicks\",\"type\":\"uint128\"}],\"name\":\"startChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vmParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gracePeriodTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arbGasSpeedLimitPerTick\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"maxExecutionSteps\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// ArbRollupFuncSigs maps the 4-byte function signature to its string representation.
var ArbRollupFuncSigs = map[string]string{
	"5dbaf68b": "challengeFactory()",
	"d6e51259": "confirmInvalid(uint256,bytes32,uint256,bytes32,address[],bytes32[],uint256[])",
	"1ec90093": "confirmInvalidFromSnapshot(uint256,bytes32,uint256,bytes32,uint256,bytes32[],bytes32[],uint256[])",
	"ce2dbd38": "confirmValid(uint256,bytes,bytes32,bytes32,address[],bytes32[],uint256[])",
	"1e520189": "confirmValidFromSnapshot(uint256,bytes,bytes32,bytes32,uint256,bytes32[],bytes32[],uint256[])",
	"c3f8ae34": "getMySnapshot(uint256)",
	"d16c305d": "getStakeRequired()",
	"d489113a": "globalInbox()",
	"19f4c3a7": "init(bytes32,uint128,uint128,uint64,uint128,address,address,address)",
	"6177fd18": "isStaked(address)",
	"57ca6d1b": "isValidLeaf(bytes32)",
	"65f7f80d": "latestConfirmed()",
	"d684f94b": "makeAssertion(bytes32[9],uint256,uint256,uint32,uint64,uint128[2],uint256,bool,uint64,bytes32[])",
	"dbad0a39": "moveStake(bytes32[],bytes32[])",
	"e0620d64": "placeStake(bytes32[],bytes32[])",
	"ef5f7cb9": "pruneLeaf(bytes32,bytes32[],bytes32[])",
	"7cfaaf67": "recoverStakeConfirmed(bytes32[])",
	"33554032": "recoverStakeMooted(address,bytes32,bytes32[],bytes32[])",
	"113ec9d8": "recoverStakeOld(address,bytes32[])",
	"badb3f14": "recoverStakePassedDeadline(address,uint256,bytes32,uint256,bytes32,bytes32[])",
	"6bc3cd22": "resolveChallenge(address,address,uint256)",
	"35fa6a6a": "snapshotDeadlineStakers(uint256,uint256,address[],address[])",
	"3dbcf76f": "snapshotLatestConfirmed(uint256)",
	"4cd525a1": "snapshotLeafNodeExists(uint256,bytes32)",
	"b7c83f3d": "snapshotStakerNodeExists(uint256,address)",
	"3cdb5dbe": "snapshotTwoStakers(uint256,address,address)",
	"bac5963f": "startChallenge(address,address,bytes32,uint256,uint256[2],bytes32[2],bytes32[],bytes32[],bytes32,bytes32,uint128)",
	"bbc2cc00": "vmParams()",
}

// ArbRollupBin is the compiled bytecode used for deploying new contracts.
var ArbRollupBin = "0x608060405234801561001057600080fd5b506155a280620000216000396000f3fe6080604052600436106101b75760003560e01c80637cfaaf67116100ec578063d16c305d1161008a578063d6e5125911610064578063d6e51259146110b9578063dbad0a39146111ec578063e0620d64146112b7578063ef5f7cb914611375576101b7565b8063d16c305d14610fa7578063d489113a14610fd8578063d684f94b14610fed576101b7565b8063badb3f14116100c6578063badb3f1414610d1f578063bbc2cc0014610dc2578063c3f8ae3414610dff578063ce2dbd3814610e29576101b7565b80637cfaaf6714610aac578063b7c83f3d14610b27578063bac5963f14610b60576101b7565b80633dbcf76f116101595780635dbaf68b116101335780635dbaf68b146109de5780636177fd1814610a0f57806365f7f80d14610a425780636bc3cd2214610a69576101b7565b80633dbcf76f146109465780634cd525a11461097057806357ca6d1b146109a0576101b7565b80631ec90093116101955780631ec900931461051757806333554032146106e957806335fa6a6a146107c95780633cdb5dbe14610905576101b7565b8063113ec9d8146101bc57806319f4c3a7146102495780631e520189146102c6575b600080fd5b3480156101c857600080fd5b50610247600480360360408110156101df57600080fd5b6001600160a01b038235169190810190604081016020820135600160201b81111561020957600080fd5b82018360208201111561021b57600080fd5b803590602001918460208302840111600160201b8311171561023c57600080fd5b509092509050611447565b005b34801561025557600080fd5b50610247600480360361010081101561026d57600080fd5b508035906001600160801b036020820135811691604081013582169167ffffffffffffffff606083013516916080810135909116906001600160a01b0360a082013581169160c081013582169160e09091013516611538565b3480156102d257600080fd5b5061024760048036036101008110156102ea57600080fd5b81359190810190604081016020820135600160201b81111561030b57600080fd5b82018360208201111561031d57600080fd5b803590602001918460018302840111600160201b8311171561033e57600080fd5b91908080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152509295843595602086013595604081013595509193509150608081019060600135600160201b8111156103a257600080fd5b8201836020820111156103b457600080fd5b803590602001918460208302840111600160201b831117156103d557600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561042457600080fd5b82018360208201111561043657600080fd5b803590602001918460208302840111600160201b8311171561045757600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156104a657600080fd5b8201836020820111156104b857600080fd5b803590602001918460208302840111600160201b831117156104d957600080fd5b919080806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250929550611578945050505050565b34801561052357600080fd5b50610247600480360361010081101561053b57600080fd5b8135916020810135916040820135916060810135916080820135919081019060c0810160a0820135600160201b81111561057457600080fd5b82018360208201111561058657600080fd5b803590602001918460208302840111600160201b831117156105a757600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156105f657600080fd5b82018360208201111561060857600080fd5b803590602001918460208302840111600160201b8311171561062957600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561067857600080fd5b82018360208201111561068a57600080fd5b803590602001918460208302840111600160201b831117156106ab57600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295506115c4945050505050565b3480156106f557600080fd5b506102476004803603608081101561070c57600080fd5b6001600160a01b0382351691602081013591810190606081016040820135600160201b81111561073b57600080fd5b82018360208201111561074d57600080fd5b803590602001918460208302840111600160201b8311171561076e57600080fd5b919390929091602081019035600160201b81111561078b57600080fd5b82018360208201111561079d57600080fd5b803590602001918460208302840111600160201b831117156107be57600080fd5b509092509050611648565b3480156107d557600080fd5b50610247600480360360808110156107ec57600080fd5b813591602081013591810190606081016040820135600160201b81111561081257600080fd5b82018360208201111561082457600080fd5b803590602001918460208302840111600160201b8311171561084557600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561089457600080fd5b8201836020820111156108a657600080fd5b803590602001918460208302840111600160201b831117156108c757600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295506117a0945050505050565b34801561091157600080fd5b506102476004803603606081101561092857600080fd5b508035906001600160a01b0360208201358116916040013516611a51565b34801561095257600080fd5b506102476004803603602081101561096957600080fd5b5035611a87565b34801561097c57600080fd5b506102476004803603604081101561099357600080fd5b5080359060200135611a96565b3480156109ac57600080fd5b506109ca600480360360208110156109c357600080fd5b5035611ab6565b604080519115158252519081900360200190f35b3480156109ea57600080fd5b506109f3611ace565b604080516001600160a01b039092168252519081900360200190f35b348015610a1b57600080fd5b506109ca60048036036020811015610a3257600080fd5b50356001600160a01b0316611add565b348015610a4e57600080fd5b50610a57611afa565b60408051918252519081900360200190f35b348015610a7557600080fd5b5061024760048036036060811015610a8c57600080fd5b506001600160a01b03813581169160208101359091169060400135611b00565b348015610ab857600080fd5b5061024760048036036020811015610acf57600080fd5b810190602081018135600160201b811115610ae957600080fd5b820183602082011115610afb57600080fd5b803590602001918460208302840111600160201b83111715610b1c57600080fd5b509092509050611c5c565b348015610b3357600080fd5b5061024760048036036040811015610b4a57600080fd5b50803590602001356001600160a01b0316611c99565b348015610b6c57600080fd5b5061024760048036036101a0811015610b8457600080fd5b6040805180820182526001600160a01b0384358116946020810135909116938382013593606083013593918301929160c083019160808401906002908390839080828437600092019190915250506040805180820182529295949381810193925090600290839083908082843760009201919091525091949392602081019250359050600160201b811115610c1857600080fd5b820183602082011115610c2a57600080fd5b803590602001918460208302840111600160201b83111715610c4b57600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b811115610c9a57600080fd5b820183602082011115610cac57600080fd5b803590602001918460208302840111600160201b83111715610ccd57600080fd5b91908080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525092955050823593505050602081013590604001356001600160801b0316611cb4565b348015610d2b57600080fd5b50610247600480360360c0811015610d4257600080fd5b6001600160a01b03823516916020810135916040820135916060810135916080820135919081019060c0810160a0820135600160201b811115610d8457600080fd5b820183602082011115610d9657600080fd5b803590602001918460208302840111600160201b83111715610db757600080fd5b50909250905061225a565b348015610dce57600080fd5b50610dd76123d5565b60408051938452602084019290925267ffffffffffffffff1682820152519081900360600190f35b348015610e0b57600080fd5b50610a5760048036036020811015610e2257600080fd5b50356123eb565b348015610e3557600080fd5b50610247600480360360e0811015610e4c57600080fd5b81359190810190604081016020820135600160201b811115610e6d57600080fd5b820183602082011115610e7f57600080fd5b803590602001918460018302840111600160201b83111715610ea057600080fd5b919390928235926020810135929190606081019060400135600160201b811115610ec957600080fd5b820183602082011115610edb57600080fd5b803590602001918460208302840111600160201b83111715610efc57600080fd5b919390929091602081019035600160201b811115610f1957600080fd5b820183602082011115610f2b57600080fd5b803590602001918460208302840111600160201b83111715610f4c57600080fd5b919390929091602081019035600160201b811115610f6957600080fd5b820183602082011115610f7b57600080fd5b803590602001918460208302840111600160201b83111715610f9c57600080fd5b509092509050612406565b348015610fb357600080fd5b50610fbc6125c0565b604080516001600160801b039092168252519081900360200190f35b348015610fe457600080fd5b506109f36125cf565b348015610ff957600080fd5b50610247600480360361026081101561101157600080fd5b610120820135906101408301359063ffffffff610160850135169067ffffffffffffffff6101808601358116916101a08701916101e0880135916102008901351515916102208a013516908901896102608101610240820135600160201b81111561107b57600080fd5b82018360208201111561108d57600080fd5b803590602001918460208302840111600160201b831117156110ae57600080fd5b5090925090506125de565b3480156110c557600080fd5b50610247600480360360e08110156110dc57600080fd5b81359160208101359160408201359160608101359181019060a081016080820135600160201b81111561110e57600080fd5b82018360208201111561112057600080fd5b803590602001918460208302840111600160201b8311171561114157600080fd5b919390929091602081019035600160201b81111561115e57600080fd5b82018360208201111561117057600080fd5b803590602001918460208302840111600160201b8311171561119157600080fd5b919390929091602081019035600160201b8111156111ae57600080fd5b8201836020820111156111c057600080fd5b803590602001918460208302840111600160201b831117156111e157600080fd5b50909250905061280d565b3480156111f857600080fd5b506102476004803603604081101561120f57600080fd5b810190602081018135600160201b81111561122957600080fd5b82018360208201111561123b57600080fd5b803590602001918460208302840111600160201b8311171561125c57600080fd5b919390929091602081019035600160201b81111561127957600080fd5b82018360208201111561128b57600080fd5b803590602001918460208302840111600160201b831117156112ac57600080fd5b509092509050612923565b610247600480360360408110156112cd57600080fd5b810190602081018135600160201b8111156112e757600080fd5b8201836020820111156112f957600080fd5b803590602001918460208302840111600160201b8311171561131a57600080fd5b919390929091602081019035600160201b81111561133757600080fd5b82018360208201111561134957600080fd5b803590602001918460208302840111600160201b8311171561136a57600080fd5b509092509050612a34565b34801561138157600080fd5b506102476004803603606081101561139857600080fd5b81359190810190604081016020820135600160201b8111156113b957600080fd5b8201836020820111156113cb57600080fd5b803590602001918460208302840111600160201b831117156113ec57600080fd5b919390929091602081019035600160201b81111561140957600080fd5b82018360208201111561141b57600080fd5b803590602001918460208302840111600160201b8311171561143c57600080fd5b509092509050612b47565b60408051808201909152600e81526d0a48a86ac9e9888be988a9c8ea8960931b6020820152816114f55760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b838110156114ba5781810151838201526020016114a2565b50505050905090810190601f1680156114e75780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b5061153383838380806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612d4092505050565b505050565b6115458888888885612ddf565b61154f8483612eb0565b5050600c80546001600160a01b0319166001600160a01b03929092169190911790555050505050565b6115ba6040518061010001604052808a815260200189815260200188815260200187815260200186815260200185815260200184815260200183815250612fe6565b5050505050505050565b60408051808201909152600d81526c434f4e465f494e565f5459504560981b6020820152600387106116375760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b506115ba888888888888888861312b565b6000611653336133b9565b90508282600081811061166257fe5b905060200201358585600081811061167657fe5b90506020020135141580156116cd575061168e611afa565b6116cb8787878080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061344992505050565b145b80156117145750806117128785858080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061344992505050565b145b604051806040016040528060148152602001732922a1a7ab2fa1a7a7232624a1aa2fa82927a7a360611b8152509061178d5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b5061179787613460565b50505050505050565b81518151600a8054604080518082019091529182526910d210d2d7d0d3d5539560b21b6020830152828401146118175760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b50606082604051908082528060200260200182016040528015611844578160200160208202803883390190505b5090506000805b8481101561195257600087828151811061186157fe5b60200260200101519050826001600160601b0319168160601b6001600160601b031916116040518060400160405280600a81526020016921a421a5afa7a92222a960b11b815250906118f45760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b508060601b92506000611906826134e9565b60018101549091508a90611922906001600160801b0316613573565b1061192c57600080fd5b806000015485848151811061193d57fe5b6020908102919091010152505060010161184b565b5060009050805b83811015611a4557600086828151811061196f57fe5b60200260200101519050826001600160601b0319168160601b6001600160601b031916116040518060400160405280600a81526020016921a421a5afa7a92222a960b11b81525090611a025760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b508060601b92506000611a14826134e9565b60018101549091508a90611a30906001600160801b0316613573565b1015611a3b57600080fd5b5050600101611959565b506115ba88888461357a565b6000611a5c836134e9565b90506000611a69836134e9565b9050611a808585846000015486856000015461363b565b5050505050565b611a93816006546136ce565b50565b611a9f81611ab6565b611aa857600080fd5b611ab28282613739565b5050565b60008181526005602052604090205460ff165b919050565b6007546001600160a01b031681565b6001600160a01b0316600090815260096020526040902054151590565b60065490565b336000908152600b6020908152604091829020548251808401909352600f83526e2922a9afa1a420a62fa9a2a72222a960891b9183019190915260ff16611b885760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b50336000908152600b60205260408120805460ff19169055611ba9846134e9565b6008546040519192506001600160a01b0386169160026001600160801b039283160490911680156108fc02916000818181858888f19350505050158015611bf4573d6000803e3d6000fd5b5060018101805460ff60801b19169055611c0d836137a4565b604080513381526001600160a01b03808716602083015285168183015290517f468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f299181900360600190a150505050565b611ab233838380806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250612d4092505050565b6000611ca4826134e9565b9050611533838260000154613739565b6000611cbf8c6134e9565b90506000611ccc8c6134e9565b60018301549091508a90611ce8906001600160801b0316613573565b106040518060400160405280600d81526020016c53544b315f444541444c494e4560981b81525090611d5b5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b5060018101548a90611d75906001600160801b0316613573565b106040518060400160405280600d81526020016c53544b325f444541444c494e4560981b81525090611de85760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b50600182015460408051808201909152600c81526b14d512cc57d25397d0d2105360a21b602082015290600160801b900460ff1615611e685760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b50600181015460408051808201909152600c81526b14d512cc57d25397d0d2105360a21b602082015290600160801b900460ff1615611ee85760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b506020808a01518a5160408051808201909152600a8152692a2ca822afa7a92222a960b11b9381019390935211611f605760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b508154611f88611f828d8d898e600060200201518e60005b60200201516137e5565b89613449565b146040518060400160405280600c81526020016b20a9a9a2a92a2fa82927a7a360a11b81525090611ffa5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b50805461202b6120258d8d612018896001600160801b038a1661384d565b60208f01518e6001611f78565b88613449565b146040518060400160405280600a81526020016921a420a62fa82927a7a360b11b8152509061209b5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b5060018260010160106101000a81548160ff02191690831515021790555060018160010160106101000a81548160ff0219169083151502179055506000600760009054906101000a90046001600160a01b03166001600160a01b031663865da1c28f8f87898f60016002811061210d57fe5b60200201516040518663ffffffff1660e01b815260040180866001600160a01b03166001600160a01b03168152602001856001600160a01b03166001600160a01b03168152602001846001600160801b0316815260200183815260200182815260200195505050505050602060405180830381600087803b15801561219157600080fd5b505af11580156121a5573d6000803e3d6000fd5b505050506040513d60208110156121bb57600080fd5b50516001600160a01b0381166000908152600b60205260409020805460ff191660019081179091559091507f6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f908f908f908d9060209081029190910151604080516001600160a01b0395861681529385169284019290925282820152918416606082015290519081900360800190a15050505050505050505050505050565b6000612265336133b9565b9050600061227682898989896137e5565b905060006122b78286868080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061344992505050565b90506122c281611ab6565b604051806040016040528060138152602001722922a1a7ab2fa222a0a22624a722afa622a0a360691b8152509061233a5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b5061234489613573565b431015604051806040016040528060138152602001725245434f565f444541444c494e455f54494d4560681b815250906123bf5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b506123c98a613460565b50505050505050505050565b60025460035460045467ffffffffffffffff1683565b33600090815260208181526040808320938352929052205490565b6124f08b61245261244c8d8d8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061387992505050565b8b61384d565b60038a8a8a8080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808e0282810182019093528d82529093508d92508c91829185019084908082843760009201919091525050604080516020808d0282810182019093528c82529093508c92508b91829185019084908082843760009201919091525061392c92505050565b60015460405163e4eb8c6360e01b8152602060048201908152602482018c90526001600160a01b039092169163e4eb8c63918d918d918190604401848480828437600081840152601f19601f8201169050808301925050509350505050600060405180830381600087803b15801561256757600080fd5b505af115801561257b573d6000803e3d6000fd5b5050604080518b815290517f7c4ea4965dec519bdc58e57940c14ed469185c38f401798f2f38ed6d0afb1fd39350908190036020019150a15050505050505050505050565b6008546001600160801b031690565b6001546001600160a01b031681565b60008061272c6040518061022001604052808f6000600981106125fd57fe5b602002013581526020018f60016009811061261457fe5b602002013581526020018e81526020018f60026009811061263157fe5b602002013581526020018d81526020018f60036009811061264e57fe5b602002013581526020018c63ffffffff1681526020018b67ffffffffffffffff1681526020018a600280602002604051908101604052809291908260026020028082843760009201919091525050508152602081018a90526040018f6004602002013581526020018f6005600981106126c357fe5b602002013581526020018f6006600981106126da57fe5b6020020135815260200188151581526020018767ffffffffffffffff1681526020018f60076009811061270957fe5b602002013581526020018f60086009811061272057fe5b60200201359052613a52565b91509150600061273b336133b9565b90508261277b8287878080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061344992505050565b146040518060400160405280601181526020017026a0a5a2afa9aa20a5a2a92fa82927a7a360791b815250906127f25760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b506127fd3383613f3b565b5050505050505050505050505050565b60408051808201909152600d81526c434f4e465f494e565f5459504560981b6020820152600389106128805760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b506123c98a8a8a8a8a8a8080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525050604080516020808e0282810182019093528d82529093508d92508c91829185019084908082843760009201919091525050604080516020808d0282810182019093528c82529093508c92508b91829185019084908082843760009201919091525061392c92505050565b600061292e336133b9565b9050600061296f8287878080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061344992505050565b905060006129b08286868080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061344992505050565b90506129bb81611ab6565b6040518060400160405280600981526020016826a7ab22afa622a0a360b91b81525090612a295760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b506117973383613f3b565b6000612a7a612a41611afa565b86868080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061344992505050565b90506000612abb8285858080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061344992505050565b9050612ac681611ab6565b6040518060400160405280600a815260200169282620a1a2afa622a0a360b11b81525090612b355760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b50612b3f82613f94565b505050505050565b6000612b868686868080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061344992505050565b9050612b9181611ab6565b6040518060400160405280600a81526020016928292aa722afa622a0a360b11b81525090612c005760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b5082826000818110612c0e57fe5b9050602002013585856000818110612c2257fe5b9050602002013514158015612c795750612c3a611afa565b612c778785858080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525061344992505050565b145b6040518060400160405280600e81526020016d141495539157d0d3d391931250d560921b81525090612cec5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b50600081815260056020908152604091829020805460ff19169055815183815291517f3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f44909509281900390910190a1505050505050565b6000612d4b336133b9565b9050612d55611afa565b612d5f8284613449565b146040518060400160405280601081526020016f2922a1a7ab2fa820aa242fa82927a7a360811b81525090612dd55760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b5061153383613460565b600180546001600160a01b0319166001600160a01b0383161790556000612e0f86612e08614143565b60006141b6565b90506000612e2081808080866137e5565b6006819055600081815260056020908152604091829020805460ff191660011790556001600160801b03808a1660025588166003556004805467ffffffffffffffff891667ffffffffffffffff1990911617905581518a815291519293507f4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d92918290030190a150505050505050565b60075460408051808201909152600a815269494e49545f545749434560b01b6020820152906001600160a01b031615612f2a5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b5060408051808201909152600c81526b494e49545f4e4f4e5a45524f60a01b60208201526001600160a01b038216612fa35760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b50600780546001600160a01b0319166001600160a01b0392909216919091179055600880546001600160801b0319166001600160801b0392909216919091179055565b6130288160000151613008612ffe8460200151613879565b846040015161384d565b6003846060015185608001518660a001518760c001518860e0015161312b565b60015460208083015160405163e4eb8c6360e01b8152600481018381528251602483015282516001600160a01b039095169463e4eb8c6394919283926044909101919085019080838360005b8381101561308c578181015183820152602001613074565b50505050905090810190601f1680156130b95780820380516001836020036101000a031916815260200191505b5092505050600060405180830381600087803b1580156130d857600080fd5b505af11580156130ec573d6000803e3d6000fd5b505050604080830151815190815290517f7c4ea4965dec519bdc58e57940c14ed469185c38f401798f2f38ed6d0afb1fd392509081900360200190a150565b60008351116040518060400160405280600f81526020016e21a7a7232fa420a9afa9aa20a5a2a960891b815250906131a45760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b5060006131bb6131b2611afa565b8a8a8a8a6137e5565b9050886131c743613573565b101560405180604001604052806009815260200168434f4e465f54494d4560b81b815250906132375760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b503360009081526020818152604080832088845290915290205461325b8a866141ed565b146040518060400160405280600d81526020016c10d3d39197d4d3905414d213d5609a1b815250906132ce5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b5060005b84518110156133a4578481815181106132e757fe5b6020026020010151613324838686858151811061330057fe5b602002602001015187866001018151811061331757fe5b602002602001015161428d565b146040518060400160405280601181526020017021a421a5afa9aa20a5a2a92fa82927a7a360791b8152509061339b5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b506001016132d2565b506133ae816142f7565b505050505050505050565b6001600160a01b0381166000908152600960209081526040808320548151808301909252600a82526924a72b2fa9aa20a5a2a960b11b92820192909252816134425760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b5092915050565b600061345983836000855161428d565b9392505050565b613469816137a4565b6008546040516001600160a01b038316916001600160801b031680156108fc02916000818181858888f193505050501580156134a9573d6000803e3d6000fd5b50604080516001600160a01b038316815290517f953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c9181900360200190a150565b6001600160a01b038116600090815260096020908152604080832080548251808401909352600a83526924a72b2fa9aa20a5a2a960b11b93830193909352916134425760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b6132c80290565b600061358683836141ed565b336000818152602081815260408083208984528252808320859055805184815280830189905260608101869052608091810182815288519282019290925287519596507f74ea644e404c0a911c3b4cceddbacb969cff8a6efc7efae69d1d9be45e6f1983958994899489949260a08501928783019291909102908190849084905b8381101561361f578181015183820152602001613607565b505050509050019550505050505060405180910390a150505050565b600061364985858585614332565b336000818152602081815260408083208b845282529182902084905581519283526001600160a01b0389811691840191909152828201889052861660608301526080820185905260a08201839052519192507f18410fe1e6e0f23683d25f04192e6b95d64681eee6fc2abe5241d2f58cbfbe52919081900360c00190a1505050505050565b60006136d9826143c1565b3360008181526020818152604080832088845282529182902084905581519283528201859052818101839052519192507f01e422abe4c07a9d56a7f67171e2f76848c67d632c74dcd3a5cbb50c63c22ca2919081900360600190a1505050565b600061374482614403565b3360008181526020818152604080832088845282529182902084905581519283528201859052818101839052519192507f98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556919081900360600190a1505050565b6001600160a01b03166000908152600960205260408120908155600101805470ffffffffffffffffffffffffffffffffff19169055600a8054600019019055565b6040805160208082018490528183018790526060820186905260808083018690528351808403909101815260a08301845280519082012060c0830189905260e08084019190915283518084039091018152610100909201909252805191012095945050505050565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b8051600090819081908190815b81811015613921576138988782614418565b9196509093509050846138eb576040805162461bcd60e51b8152602060048201526016602482015275496e76616c6964206f7574707574206d65737361676560501b604482015290519081900360640190fd5b83836040516020018083815260200182815260200192505050604051602081830303815290604052805190602001209350613886565b509195945050505050565b6000613942613939611afa565b898989896137e5565b90508761394e43613573565b101560405180604001604052806009815260200168434f4e465f54494d4560b81b815250906139be5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b5060006139ce828a87878761446f565b9050600081116040518060400160405280600f81526020016e21a7a7232fa420a9afa9aa20a5a2a960891b81525090613a485760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b506133ae826142f7565b6000806000613a6e8460000151856020015186604001516141b6565b90506000613a95856060015186608001518760a001518860c0015163ffffffff16866137e5565b9050613aa081611ab6565b6040518060400160405280600981526020016826a0a5a2afa622a0a360b91b81525090613b0e5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b508451613b1a90614707565b158015613b2f57508451613b2d9061470d565b155b6040518060400160405280600881526020016726a0a5a2afa92aa760c11b81525090613b9c5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b5060045460e086015160408051808201909152600981526804d414b455f535445560bc1b60208201529167ffffffffffffffff90811691161115613c215760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b50613c30856101000151614711565b604051806040016040528060098152602001684d414b455f54494d4560b81b81525090613c9e5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b506101208501511580613cb35750846101a001515b6040518060400160405280600d81526020016c4d414b455f4d4553534147455360981b81525090613d255760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b50600154604080516308d74f6960e11b8152815160009384936001600160a01b03909116926311ae9ed2926004808301939282900301818787803b158015613d6c57600080fd5b505af1158015613d80573d6000803e3d6000fd5b505050506040513d6040811015613d9657600080fd5b50805160209091015160408901519193509150613dba90829063ffffffff61474116565b87610120015111156040518060400160405280601081526020016f135052d157d35154d4d051d157d0d39560821b81525090613e375760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b506002546003546101c08901516000919067ffffffffffffffff1681613e5957fe5b049050600082613e6843613573565b0190508960800151811015613e7e575060808901515b81016000613e918b888489898d8a614783565b90506000613ea28c89858c896147d4565b90506000613eb48d8a868d8a8a614833565b90506000613ec38e8b876148bd565b6000858152600560205260408082208054600160ff19918216811790925587845282842080548216831790558684528284208054821683179055848452828420805482169092179091558d83529120805490911690559050613f278e8b8b8b6148ff565b989b50979950505050505050505050915091565b6001600160a01b0382166000818152600960209081526040918290208490558151928352820183905280517fbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f49281900390910190a15050565b60085460408051808201909152600781526614d512d7d0535560ca1b6020820152906001600160801b0316341461400c5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b5033600090815260096020908152604091829020548251808401909352600c83526b105314911657d4d51052d15160a21b91830191909152156140905760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b50604080516060810182528281526001600160801b03438116602080840191825260008486018181523380835260098452918790209551865592516001958601805494511515600160801b0260ff60801b19929096166001600160801b0319909516949094171693909317909155600a8054909301909255825190815290810183905281517fcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88929181900390910190a150565b6040805160008082526020808301808552600360f81b948401948552835192946003938593919260418501929091028083838a5b8381101561418f578181015183820152602001614177565b50505050905001925050506040516020818303038152906040528051906020012091505090565b6040805160208082019590955280820193909352606080840192909252805180840390920182526080909201909152805191012090565b600080805b835181101561424c5783818151811061420757fe5b602002602001015182604051602001808381526020018281526020019250505060405160208183030381529060405280519060200120915080806001019150506141f2565b5060408051600160f91b6020808301919091526021820196909652604180820193909352815180820390930183526061019052805193019290922092915050565b600084835b838110156142eb57818682815181106142a757fe5b602002602001015160405160200180838152602001828152602001925050506040516020818303038152906040528051906020012091508080600101915050614292565b5090505b949350505050565b60068190556040805182815290517f9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f639181900360200190a150565b60006001858585856040516020018086600381111561434d57fe5b60ff1660f81b8152600101856001600160a01b03166001600160a01b031660601b8152601401848152602001836001600160a01b03166001600160a01b031660601b815260140182815260200195505050505050604051602081830303815290604052805190602001209050949350505050565b6040516000908190839060200180835b60ff1660f81b815260010182815260200192505050604051602081830303815290604052805190602001209050919050565b604051600090600390839060200180836143d1565b6000806000806000614428615506565b6144328888614a2b565b92509250925082614450575060009450859350849250614468915050565b60018261445c83614b7a565b51919750955093505050505b9250925092565b60008084519050600a5481146040518060400160405280600a81526020016910d210d2d7d0d3d5539560b21b815250906144ea5760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b50825181600101146040518060400160405280600c81526020016b4348434b5f4f46465345545360a01b815250906145635760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b50600080805b838110156146fa57600088828151811061457f57fe5b60200260200101519050836001600160601b0319168160601b6001600160601b031916116040518060400160405280600a81526020016921a421a5afa7a92222a960b11b815250906146125760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b50600061461e826134e9565b60018101549091508b9061463a906001600160801b0316613573565b10156146ec57806000015461466d8d8b8b878151811061465657fe5b60200260200101518c886001018151811061331757fe5b146040518060400160405280601181526020017021a421a5afa9aa20a5a2a92fa82927a7a360791b815250906146e45760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b506001909301925b5060601b9250600101614569565b5098975050505050505050565b60011490565b1590565b80516000906001600160801b0316431080159061473b575060208201516001600160801b03164311155b92915050565b600061345983836040518060400160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250614cb0565b6000806147a3896101400151878b61012001518c604001510188036141b6565b90506147c788886147bf846147b86001613573565b880161384d565b6000886137e5565b9998505050505050505050565b6000806147fe87602001518861014001516147ed614143565b8a61016001518b6101200151614d0a565b90506000614817826148106001613573565b860161384d565b90506148278787836001896137e5565b98975050505050505050565b60008061484f88600001518961010001518a6101600151614d50565b905060006148818961018001518a6101a001518b6101c001516000801b8d6101e001516000801b8f6102000151614da2565b905060006148948a60e001518484614e05565b90506148af89896148a784898b0161384d565b60028b6137e5565b9a9950505050505050505050565b60006142ef83836148d8876101e0015188610200015161384d565b60036148fa8961018001518a61014001518b61012001518c60400151016141b6565b6137e5565b7f5761ea2104e5d52e617adb7f0bfc8970ffa1d06f57d28cb2bb3a034532c970356040518060e00160405280858152602001848152602001866101400151815260200186610160015181526020018661018001518152602001866101e00151815260200186610200015181525082866101200151876101000151886101c001518960e001518a6101a001516040518088600760200280838360005b838110156149b257818101518382015260200161499a565b5050505090500187815260200186815260200185600260200280838360005b838110156149e95781810151838201526020016149d1565b50505067ffffffffffffffff9788169390910192835250509290931660208301521515604080830191909152519081900360600195509350505050a150505050565b600080614a36615506565b84518410614a5657600084614a4b6000614e4d565b925092509250614468565b6000808590506000878281518110614a6a57fe5b016020015160019092019160f81c90506000614a84615534565b60ff8316614ab857614a968a85614ecb565b919650945091508484614aa884614e4d565b9750975097505050505050614468565b60ff831660011415614ae057614ace8a85614f1e565b919650945090508484614aa88361507f565b60ff831660021415614b0857614af68a85614ecb565b919650945091508484614aa8846150df565b600360ff841610801590614b1f5750600c60ff8416105b15614b5a5760021983016060614b36828d8861515d565b919850965090508686614b488361521b565b99509950995050505050505050614468565b600080614b676000614e4d565b9199509750955050505050509250925092565b614b8261555b565b6060820151600c60ff90911610614bd4576040805162461bcd60e51b8152602060048201526011602482015270496e76616c6964207479706520636f646560781b604482015290519081900360640190fd5b606082015160ff16614c01576040518060200160405280614bf884600001516152cb565b90529050611ac9565b606082015160ff1660011415614c48576040518060200160405280614bf88460200151600001518560200151604001518660200151606001518760200151602001516152ef565b606082015160ff1660021415614c6d5750604080516020810190915281518152611ac9565b600360ff16826060015160ff1610158015614c9157506060820151600c60ff909116105b15614cae576040518060200160405280614bf88460400151615397565bfe5b60008184841115614d025760405162461bcd60e51b81526020600482018181528351602484015283519092839260449091019190850190808383600083156114ba5781810151838201526020016114a2565b505050900390565b60408051602080820197909752808201959095526060850193909352608084019190915260a0808401919091528151808403909101815260c09092019052805191012090565b815160209283015160408051808601969096526001600160801b0319608093841b81168783015291831b9091166050860152606080860193909352805180860390930183529301909252815191012090565b6040805160208082019990995296151560f81b8782015260c09590951b6001600160c01b031916604187015260498601939093526069850191909152608984015260a9808401919091528151808403909101815260c99092019052805191012090565b6040805160c09490941b6001600160c01b0319166020808601919091526028850193909352604880850192909252805180850390920182526068909301909252815191012090565b614e55615506565b604080516080808201835284825282519081018352600080825260208281018290528285018290526060830182905280840192909252835181815291820184529192830191614eba565b614ea7615506565b815260200190600190039081614e9f5790505b508152600060209091015292915050565b6000806000808551905084811080614ee557506020858203105b15614efa575060009250839150829050614468565b600160208601614f10888863ffffffff6154e316565b935093509350509250925092565b600080614f29615534565b60008490506000868281518110614f3c57fe5b602001015160f81c60f81b60f81c905081806001019250506000878381518110614f6257fe5b016020015160019384019360f89190911c915060009060ff84161415614fe9576000614f8c615506565b614f968b87614a2b565b909750909250905081614fda575050604080516080810182526000808252602082018190529181018290526060810182905290975088965094506144689350505050565b614fe381614b7a565b51925050505b6000614ffb8a8663ffffffff6154e316565b90506020850194508360ff1660011415615047576040805160808101825260ff909416845260208401919091526001908301819052606083019190915295509193509091506144689050565b6040805160808101825260ff949094168452602084019190915260009083018190526060830152506001989297509550909350505050565b615087615506565b6040805160808101825260008082526020808301869052835182815290810184529192830191906150ce565b6150bb615506565b8152602001906001900390816150b35790505b508152600160209091015292915050565b6150e7615506565b60408051608080820183528482528251908101835260008082526020828101829052828501829052606083018290528084019290925283518181529182018452919283019161514c565b615139615506565b8152602001906001900390816151315790505b508152600260209091015292915050565b60008060606000849050600060608860ff166040519080825280602002602001820160405280156151a857816020015b615195615506565b81526020019060019003908161518d5790505b50905060005b8960ff168160ff161015615205576151c68985614a2b565b8451859060ff86169081106151d757fe5b602090810291909101015294509250826151fd5750600095508694509250615212915050565b6001016151ae565b5060019550919350909150505b93509350939050565b615223615506565b61522d82516154ff565b61527e576040805162461bcd60e51b815260206004820152601a60248201527f5475706c65206d75737420686176652076616c69642073697a65000000000000604482015290519081900360640190fd5b5060408051608080820183526000808352835191820184528082526020828101829052828501829052606080840192909252830191909152918101839052915160030160ff169082015290565b60408051602080820193909352815180820384018152908201909152805191012090565b60008315615349575060408051600160f81b6020808301919091526001600160f81b031960f888901b16602183015260228201859052604280830185905283518084039091018152606290920190925280519101206142ef565b5060408051600160f81b6020808301919091526001600160f81b031960f888901b16602183015260228083018590528351808403909101815260429092019092528051910120949350505050565b60006008825111156153e7576040805162461bcd60e51b8152602060048201526014602482015273092dcecc2d8d2c840e8eae0d8ca40d8cadccee8d60631b604482015290519081900360640190fd5b60608251604051908082528060200260200182016040528015615414578160200160208202803883390190505b50805190915060005b818110156154705761542d61555b565b61544986838151811061543c57fe5b6020026020010151614b7a565b9050806000015184838151811061545c57fe5b60209081029190910101525060010161541d565b508351600360ff160182604051602001808360ff1660ff1660f81b8152600101828051906020019060200280838360005b838110156154b95781810151838201526020016154a1565b50505050905001925050506040516020818303038152906040528051906020012092505050919050565b600081602001835110156154f657600080fd5b50016020015190565b6008101590565b604051806080016040528060008152602001615520615534565b815260606020820152600060409091015290565b60408051608081018252600080825260208201819052918101829052606081019190915290565b6040805160208101909152600081529056fea265627a7a7231582009c1c4be3af18034a88a05c99af7c0a7ca53578c1fe506149de0b37b86cf66eb64736f6c63430005100032"

// DeployArbRollup deploys a new Ethereum contract, binding an instance of ArbRollup to it.
func DeployArbRollup(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ArbRollup, error) {
	parsed, err := abi.JSON(strings.NewReader(ArbRollupABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ArbRollupBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ArbRollup{ArbRollupCaller: ArbRollupCaller{contract: contract}, ArbRollupTransactor: ArbRollupTransactor{contract: contract}, ArbRollupFilterer: ArbRollupFilterer{contract: contract}}, nil
}

// ArbRollup is an auto generated Go binding around an Ethereum contract.
type ArbRollup struct {
	ArbRollupCaller     // Read-only binding to the contract
	ArbRollupTransactor // Write-only binding to the contract
	ArbRollupFilterer   // Log filterer for contract events
}

// ArbRollupCaller is an auto generated read-only Go binding around an Ethereum contract.
type ArbRollupCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbRollupTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ArbRollupTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbRollupFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ArbRollupFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ArbRollupSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ArbRollupSession struct {
	Contract     *ArbRollup        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ArbRollupCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ArbRollupCallerSession struct {
	Contract *ArbRollupCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// ArbRollupTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ArbRollupTransactorSession struct {
	Contract     *ArbRollupTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// ArbRollupRaw is an auto generated low-level Go binding around an Ethereum contract.
type ArbRollupRaw struct {
	Contract *ArbRollup // Generic contract binding to access the raw methods on
}

// ArbRollupCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ArbRollupCallerRaw struct {
	Contract *ArbRollupCaller // Generic read-only contract binding to access the raw methods on
}

// ArbRollupTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ArbRollupTransactorRaw struct {
	Contract *ArbRollupTransactor // Generic write-only contract binding to access the raw methods on
}

// NewArbRollup creates a new instance of ArbRollup, bound to a specific deployed contract.
func NewArbRollup(address common.Address, backend bind.ContractBackend) (*ArbRollup, error) {
	contract, err := bindArbRollup(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ArbRollup{ArbRollupCaller: ArbRollupCaller{contract: contract}, ArbRollupTransactor: ArbRollupTransactor{contract: contract}, ArbRollupFilterer: ArbRollupFilterer{contract: contract}}, nil
}

// NewArbRollupCaller creates a new read-only instance of ArbRollup, bound to a specific deployed contract.
func NewArbRollupCaller(address common.Address, caller bind.ContractCaller) (*ArbRollupCaller, error) {
	contract, err := bindArbRollup(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ArbRollupCaller{contract: contract}, nil
}

// NewArbRollupTransactor creates a new write-only instance of ArbRollup, bound to a specific deployed contract.
func NewArbRollupTransactor(address common.Address, transactor bind.ContractTransactor) (*ArbRollupTransactor, error) {
	contract, err := bindArbRollup(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ArbRollupTransactor{contract: contract}, nil
}

// NewArbRollupFilterer creates a new log filterer instance of ArbRollup, bound to a specific deployed contract.
func NewArbRollupFilterer(address common.Address, filterer bind.ContractFilterer) (*ArbRollupFilterer, error) {
	contract, err := bindArbRollup(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ArbRollupFilterer{contract: contract}, nil
}

// bindArbRollup binds a generic wrapper to an already deployed contract.
func bindArbRollup(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ArbRollupABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ArbRollup *ArbRollupRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ArbRollup.Contract.ArbRollupCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ArbRollup *ArbRollupRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ArbRollup.Contract.ArbRollupTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ArbRollup *ArbRollupRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ArbRollup.Contract.ArbRollupTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ArbRollup *ArbRollupCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ArbRollup.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ArbRollup *ArbRollupTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ArbRollup.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ArbRollup *ArbRollupTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ArbRollup.Contract.contract.Transact(opts, method, params...)
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() constant returns(address)
func (_ArbRollup *ArbRollupCaller) ChallengeFactory(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "challengeFactory")
	return *ret0, err
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() constant returns(address)
func (_ArbRollup *ArbRollupSession) ChallengeFactory() (common.Address, error) {
	return _ArbRollup.Contract.ChallengeFactory(&_ArbRollup.CallOpts)
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() constant returns(address)
func (_ArbRollup *ArbRollupCallerSession) ChallengeFactory() (common.Address, error) {
	return _ArbRollup.Contract.ChallengeFactory(&_ArbRollup.CallOpts)
}

// GetMySnapshot is a free data retrieval call binding the contract method 0xc3f8ae34.
//
// Solidity: function getMySnapshot(uint256 idx) constant returns(bytes32)
func (_ArbRollup *ArbRollupCaller) GetMySnapshot(opts *bind.CallOpts, idx *big.Int) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "getMySnapshot", idx)
	return *ret0, err
}

// GetMySnapshot is a free data retrieval call binding the contract method 0xc3f8ae34.
//
// Solidity: function getMySnapshot(uint256 idx) constant returns(bytes32)
func (_ArbRollup *ArbRollupSession) GetMySnapshot(idx *big.Int) ([32]byte, error) {
	return _ArbRollup.Contract.GetMySnapshot(&_ArbRollup.CallOpts, idx)
}

// GetMySnapshot is a free data retrieval call binding the contract method 0xc3f8ae34.
//
// Solidity: function getMySnapshot(uint256 idx) constant returns(bytes32)
func (_ArbRollup *ArbRollupCallerSession) GetMySnapshot(idx *big.Int) ([32]byte, error) {
	return _ArbRollup.Contract.GetMySnapshot(&_ArbRollup.CallOpts, idx)
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() constant returns(uint128)
func (_ArbRollup *ArbRollupCaller) GetStakeRequired(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "getStakeRequired")
	return *ret0, err
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() constant returns(uint128)
func (_ArbRollup *ArbRollupSession) GetStakeRequired() (*big.Int, error) {
	return _ArbRollup.Contract.GetStakeRequired(&_ArbRollup.CallOpts)
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() constant returns(uint128)
func (_ArbRollup *ArbRollupCallerSession) GetStakeRequired() (*big.Int, error) {
	return _ArbRollup.Contract.GetStakeRequired(&_ArbRollup.CallOpts)
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() constant returns(address)
func (_ArbRollup *ArbRollupCaller) GlobalInbox(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "globalInbox")
	return *ret0, err
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() constant returns(address)
func (_ArbRollup *ArbRollupSession) GlobalInbox() (common.Address, error) {
	return _ArbRollup.Contract.GlobalInbox(&_ArbRollup.CallOpts)
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() constant returns(address)
func (_ArbRollup *ArbRollupCallerSession) GlobalInbox() (common.Address, error) {
	return _ArbRollup.Contract.GlobalInbox(&_ArbRollup.CallOpts)
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) constant returns(bool)
func (_ArbRollup *ArbRollupCaller) IsStaked(opts *bind.CallOpts, _stakerAddress common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "isStaked", _stakerAddress)
	return *ret0, err
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) constant returns(bool)
func (_ArbRollup *ArbRollupSession) IsStaked(_stakerAddress common.Address) (bool, error) {
	return _ArbRollup.Contract.IsStaked(&_ArbRollup.CallOpts, _stakerAddress)
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) constant returns(bool)
func (_ArbRollup *ArbRollupCallerSession) IsStaked(_stakerAddress common.Address) (bool, error) {
	return _ArbRollup.Contract.IsStaked(&_ArbRollup.CallOpts, _stakerAddress)
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) constant returns(bool)
func (_ArbRollup *ArbRollupCaller) IsValidLeaf(opts *bind.CallOpts, leaf [32]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "isValidLeaf", leaf)
	return *ret0, err
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) constant returns(bool)
func (_ArbRollup *ArbRollupSession) IsValidLeaf(leaf [32]byte) (bool, error) {
	return _ArbRollup.Contract.IsValidLeaf(&_ArbRollup.CallOpts, leaf)
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) constant returns(bool)
func (_ArbRollup *ArbRollupCallerSession) IsValidLeaf(leaf [32]byte) (bool, error) {
	return _ArbRollup.Contract.IsValidLeaf(&_ArbRollup.CallOpts, leaf)
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() constant returns(bytes32)
func (_ArbRollup *ArbRollupCaller) LatestConfirmed(opts *bind.CallOpts) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _ArbRollup.contract.Call(opts, out, "latestConfirmed")
	return *ret0, err
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() constant returns(bytes32)
func (_ArbRollup *ArbRollupSession) LatestConfirmed() ([32]byte, error) {
	return _ArbRollup.Contract.LatestConfirmed(&_ArbRollup.CallOpts)
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() constant returns(bytes32)
func (_ArbRollup *ArbRollupCallerSession) LatestConfirmed() ([32]byte, error) {
	return _ArbRollup.Contract.LatestConfirmed(&_ArbRollup.CallOpts)
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() constant returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps)
func (_ArbRollup *ArbRollupCaller) VmParams(opts *bind.CallOpts) (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
}, error) {
	ret := new(struct {
		GracePeriodTicks        *big.Int
		ArbGasSpeedLimitPerTick *big.Int
		MaxExecutionSteps       uint64
	})
	out := ret
	err := _ArbRollup.contract.Call(opts, out, "vmParams")
	return *ret, err
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() constant returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps)
func (_ArbRollup *ArbRollupSession) VmParams() (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
}, error) {
	return _ArbRollup.Contract.VmParams(&_ArbRollup.CallOpts)
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() constant returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps)
func (_ArbRollup *ArbRollupCallerSession) VmParams() (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
}, error) {
	return _ArbRollup.Contract.VmParams(&_ArbRollup.CallOpts)
}

// ConfirmInvalid is a paid mutator transaction binding the contract method 0xd6e51259.
//
// Solidity: function confirmInvalid(uint256 deadlineTicks, bytes32 challengeNodeData, uint256 branch, bytes32 vmProtoStateHash, address[] stakerAddresses, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupTransactor) ConfirmInvalid(opts *bind.TransactOpts, deadlineTicks *big.Int, challengeNodeData [32]byte, branch *big.Int, vmProtoStateHash [32]byte, stakerAddresses []common.Address, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "confirmInvalid", deadlineTicks, challengeNodeData, branch, vmProtoStateHash, stakerAddresses, stakerProofs, stakerProofOffsets)
}

// ConfirmInvalid is a paid mutator transaction binding the contract method 0xd6e51259.
//
// Solidity: function confirmInvalid(uint256 deadlineTicks, bytes32 challengeNodeData, uint256 branch, bytes32 vmProtoStateHash, address[] stakerAddresses, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupSession) ConfirmInvalid(deadlineTicks *big.Int, challengeNodeData [32]byte, branch *big.Int, vmProtoStateHash [32]byte, stakerAddresses []common.Address, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.ConfirmInvalid(&_ArbRollup.TransactOpts, deadlineTicks, challengeNodeData, branch, vmProtoStateHash, stakerAddresses, stakerProofs, stakerProofOffsets)
}

// ConfirmInvalid is a paid mutator transaction binding the contract method 0xd6e51259.
//
// Solidity: function confirmInvalid(uint256 deadlineTicks, bytes32 challengeNodeData, uint256 branch, bytes32 vmProtoStateHash, address[] stakerAddresses, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupTransactorSession) ConfirmInvalid(deadlineTicks *big.Int, challengeNodeData [32]byte, branch *big.Int, vmProtoStateHash [32]byte, stakerAddresses []common.Address, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.ConfirmInvalid(&_ArbRollup.TransactOpts, deadlineTicks, challengeNodeData, branch, vmProtoStateHash, stakerAddresses, stakerProofs, stakerProofOffsets)
}

// ConfirmInvalidFromSnapshot is a paid mutator transaction binding the contract method 0x1ec90093.
//
// Solidity: function confirmInvalidFromSnapshot(uint256 deadlineTicks, bytes32 challengeNodeData, uint256 branch, bytes32 vmProtoStateHash, uint256 snapshotIdx, bytes32[] stakerLocations, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupTransactor) ConfirmInvalidFromSnapshot(opts *bind.TransactOpts, deadlineTicks *big.Int, challengeNodeData [32]byte, branch *big.Int, vmProtoStateHash [32]byte, snapshotIdx *big.Int, stakerLocations [][32]byte, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "confirmInvalidFromSnapshot", deadlineTicks, challengeNodeData, branch, vmProtoStateHash, snapshotIdx, stakerLocations, stakerProofs, stakerProofOffsets)
}

// ConfirmInvalidFromSnapshot is a paid mutator transaction binding the contract method 0x1ec90093.
//
// Solidity: function confirmInvalidFromSnapshot(uint256 deadlineTicks, bytes32 challengeNodeData, uint256 branch, bytes32 vmProtoStateHash, uint256 snapshotIdx, bytes32[] stakerLocations, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupSession) ConfirmInvalidFromSnapshot(deadlineTicks *big.Int, challengeNodeData [32]byte, branch *big.Int, vmProtoStateHash [32]byte, snapshotIdx *big.Int, stakerLocations [][32]byte, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.ConfirmInvalidFromSnapshot(&_ArbRollup.TransactOpts, deadlineTicks, challengeNodeData, branch, vmProtoStateHash, snapshotIdx, stakerLocations, stakerProofs, stakerProofOffsets)
}

// ConfirmInvalidFromSnapshot is a paid mutator transaction binding the contract method 0x1ec90093.
//
// Solidity: function confirmInvalidFromSnapshot(uint256 deadlineTicks, bytes32 challengeNodeData, uint256 branch, bytes32 vmProtoStateHash, uint256 snapshotIdx, bytes32[] stakerLocations, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupTransactorSession) ConfirmInvalidFromSnapshot(deadlineTicks *big.Int, challengeNodeData [32]byte, branch *big.Int, vmProtoStateHash [32]byte, snapshotIdx *big.Int, stakerLocations [][32]byte, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.ConfirmInvalidFromSnapshot(&_ArbRollup.TransactOpts, deadlineTicks, challengeNodeData, branch, vmProtoStateHash, snapshotIdx, stakerLocations, stakerProofs, stakerProofOffsets)
}

// ConfirmValid is a paid mutator transaction binding the contract method 0xce2dbd38.
//
// Solidity: function confirmValid(uint256 deadlineTicks, bytes _messages, bytes32 logsAcc, bytes32 vmProtoStateHash, address[] stakerAddresses, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupTransactor) ConfirmValid(opts *bind.TransactOpts, deadlineTicks *big.Int, _messages []byte, logsAcc [32]byte, vmProtoStateHash [32]byte, stakerAddresses []common.Address, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "confirmValid", deadlineTicks, _messages, logsAcc, vmProtoStateHash, stakerAddresses, stakerProofs, stakerProofOffsets)
}

// ConfirmValid is a paid mutator transaction binding the contract method 0xce2dbd38.
//
// Solidity: function confirmValid(uint256 deadlineTicks, bytes _messages, bytes32 logsAcc, bytes32 vmProtoStateHash, address[] stakerAddresses, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupSession) ConfirmValid(deadlineTicks *big.Int, _messages []byte, logsAcc [32]byte, vmProtoStateHash [32]byte, stakerAddresses []common.Address, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.ConfirmValid(&_ArbRollup.TransactOpts, deadlineTicks, _messages, logsAcc, vmProtoStateHash, stakerAddresses, stakerProofs, stakerProofOffsets)
}

// ConfirmValid is a paid mutator transaction binding the contract method 0xce2dbd38.
//
// Solidity: function confirmValid(uint256 deadlineTicks, bytes _messages, bytes32 logsAcc, bytes32 vmProtoStateHash, address[] stakerAddresses, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupTransactorSession) ConfirmValid(deadlineTicks *big.Int, _messages []byte, logsAcc [32]byte, vmProtoStateHash [32]byte, stakerAddresses []common.Address, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.ConfirmValid(&_ArbRollup.TransactOpts, deadlineTicks, _messages, logsAcc, vmProtoStateHash, stakerAddresses, stakerProofs, stakerProofOffsets)
}

// ConfirmValidFromSnapshot is a paid mutator transaction binding the contract method 0x1e520189.
//
// Solidity: function confirmValidFromSnapshot(uint256 deadlineTicks, bytes _messages, bytes32 logsAcc, bytes32 vmProtoStateHash, uint256 snapshotIdx, bytes32[] stakerLocations, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupTransactor) ConfirmValidFromSnapshot(opts *bind.TransactOpts, deadlineTicks *big.Int, _messages []byte, logsAcc [32]byte, vmProtoStateHash [32]byte, snapshotIdx *big.Int, stakerLocations [][32]byte, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "confirmValidFromSnapshot", deadlineTicks, _messages, logsAcc, vmProtoStateHash, snapshotIdx, stakerLocations, stakerProofs, stakerProofOffsets)
}

// ConfirmValidFromSnapshot is a paid mutator transaction binding the contract method 0x1e520189.
//
// Solidity: function confirmValidFromSnapshot(uint256 deadlineTicks, bytes _messages, bytes32 logsAcc, bytes32 vmProtoStateHash, uint256 snapshotIdx, bytes32[] stakerLocations, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupSession) ConfirmValidFromSnapshot(deadlineTicks *big.Int, _messages []byte, logsAcc [32]byte, vmProtoStateHash [32]byte, snapshotIdx *big.Int, stakerLocations [][32]byte, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.ConfirmValidFromSnapshot(&_ArbRollup.TransactOpts, deadlineTicks, _messages, logsAcc, vmProtoStateHash, snapshotIdx, stakerLocations, stakerProofs, stakerProofOffsets)
}

// ConfirmValidFromSnapshot is a paid mutator transaction binding the contract method 0x1e520189.
//
// Solidity: function confirmValidFromSnapshot(uint256 deadlineTicks, bytes _messages, bytes32 logsAcc, bytes32 vmProtoStateHash, uint256 snapshotIdx, bytes32[] stakerLocations, bytes32[] stakerProofs, uint256[] stakerProofOffsets) returns()
func (_ArbRollup *ArbRollupTransactorSession) ConfirmValidFromSnapshot(deadlineTicks *big.Int, _messages []byte, logsAcc [32]byte, vmProtoStateHash [32]byte, snapshotIdx *big.Int, stakerLocations [][32]byte, stakerProofs [][32]byte, stakerProofOffsets []*big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.ConfirmValidFromSnapshot(&_ArbRollup.TransactOpts, deadlineTicks, _messages, logsAcc, vmProtoStateHash, snapshotIdx, stakerLocations, stakerProofs, stakerProofOffsets)
}

// Init is a paid mutator transaction binding the contract method 0x19f4c3a7.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_ArbRollup *ArbRollupTransactor) Init(opts *bind.TransactOpts, _vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "init", _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// Init is a paid mutator transaction binding the contract method 0x19f4c3a7.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_ArbRollup *ArbRollupSession) Init(_vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.Init(&_ArbRollup.TransactOpts, _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// Init is a paid mutator transaction binding the contract method 0x19f4c3a7.
//
// Solidity: function init(bytes32 _vmState, uint128 _gracePeriodTicks, uint128 _arbGasSpeedLimitPerTick, uint64 _maxExecutionSteps, uint128 _stakeRequirement, address _owner, address _challengeFactoryAddress, address _globalInboxAddress) returns()
func (_ArbRollup *ArbRollupTransactorSession) Init(_vmState [32]byte, _gracePeriodTicks *big.Int, _arbGasSpeedLimitPerTick *big.Int, _maxExecutionSteps uint64, _stakeRequirement *big.Int, _owner common.Address, _challengeFactoryAddress common.Address, _globalInboxAddress common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.Init(&_ArbRollup.TransactOpts, _vmState, _gracePeriodTicks, _arbGasSpeedLimitPerTick, _maxExecutionSteps, _stakeRequirement, _owner, _challengeFactoryAddress, _globalInboxAddress)
}

// MakeAssertion is a paid mutator transaction binding the contract method 0xd684f94b.
//
// Solidity: function makeAssertion(bytes32[9] _fields, uint256 _beforePendingCount, uint256 _prevDeadlineTicks, uint32 _prevChildType, uint64 _numSteps, uint128[2] _timeBoundsBlocks, uint256 _importedMessageCount, bool _didInboxInsn, uint64 _numArbGas, bytes32[] _stakerProof) returns()
func (_ArbRollup *ArbRollupTransactor) MakeAssertion(opts *bind.TransactOpts, _fields [9][32]byte, _beforePendingCount *big.Int, _prevDeadlineTicks *big.Int, _prevChildType uint32, _numSteps uint64, _timeBoundsBlocks [2]*big.Int, _importedMessageCount *big.Int, _didInboxInsn bool, _numArbGas uint64, _stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "makeAssertion", _fields, _beforePendingCount, _prevDeadlineTicks, _prevChildType, _numSteps, _timeBoundsBlocks, _importedMessageCount, _didInboxInsn, _numArbGas, _stakerProof)
}

// MakeAssertion is a paid mutator transaction binding the contract method 0xd684f94b.
//
// Solidity: function makeAssertion(bytes32[9] _fields, uint256 _beforePendingCount, uint256 _prevDeadlineTicks, uint32 _prevChildType, uint64 _numSteps, uint128[2] _timeBoundsBlocks, uint256 _importedMessageCount, bool _didInboxInsn, uint64 _numArbGas, bytes32[] _stakerProof) returns()
func (_ArbRollup *ArbRollupSession) MakeAssertion(_fields [9][32]byte, _beforePendingCount *big.Int, _prevDeadlineTicks *big.Int, _prevChildType uint32, _numSteps uint64, _timeBoundsBlocks [2]*big.Int, _importedMessageCount *big.Int, _didInboxInsn bool, _numArbGas uint64, _stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.MakeAssertion(&_ArbRollup.TransactOpts, _fields, _beforePendingCount, _prevDeadlineTicks, _prevChildType, _numSteps, _timeBoundsBlocks, _importedMessageCount, _didInboxInsn, _numArbGas, _stakerProof)
}

// MakeAssertion is a paid mutator transaction binding the contract method 0xd684f94b.
//
// Solidity: function makeAssertion(bytes32[9] _fields, uint256 _beforePendingCount, uint256 _prevDeadlineTicks, uint32 _prevChildType, uint64 _numSteps, uint128[2] _timeBoundsBlocks, uint256 _importedMessageCount, bool _didInboxInsn, uint64 _numArbGas, bytes32[] _stakerProof) returns()
func (_ArbRollup *ArbRollupTransactorSession) MakeAssertion(_fields [9][32]byte, _beforePendingCount *big.Int, _prevDeadlineTicks *big.Int, _prevChildType uint32, _numSteps uint64, _timeBoundsBlocks [2]*big.Int, _importedMessageCount *big.Int, _didInboxInsn bool, _numArbGas uint64, _stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.MakeAssertion(&_ArbRollup.TransactOpts, _fields, _beforePendingCount, _prevDeadlineTicks, _prevChildType, _numSteps, _timeBoundsBlocks, _importedMessageCount, _didInboxInsn, _numArbGas, _stakerProof)
}

// MoveStake is a paid mutator transaction binding the contract method 0xdbad0a39.
//
// Solidity: function moveStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupTransactor) MoveStake(opts *bind.TransactOpts, proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "moveStake", proof1, proof2)
}

// MoveStake is a paid mutator transaction binding the contract method 0xdbad0a39.
//
// Solidity: function moveStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupSession) MoveStake(proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.MoveStake(&_ArbRollup.TransactOpts, proof1, proof2)
}

// MoveStake is a paid mutator transaction binding the contract method 0xdbad0a39.
//
// Solidity: function moveStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupTransactorSession) MoveStake(proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.MoveStake(&_ArbRollup.TransactOpts, proof1, proof2)
}

// PlaceStake is a paid mutator transaction binding the contract method 0xe0620d64.
//
// Solidity: function placeStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupTransactor) PlaceStake(opts *bind.TransactOpts, proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "placeStake", proof1, proof2)
}

// PlaceStake is a paid mutator transaction binding the contract method 0xe0620d64.
//
// Solidity: function placeStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupSession) PlaceStake(proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.PlaceStake(&_ArbRollup.TransactOpts, proof1, proof2)
}

// PlaceStake is a paid mutator transaction binding the contract method 0xe0620d64.
//
// Solidity: function placeStake(bytes32[] proof1, bytes32[] proof2) returns()
func (_ArbRollup *ArbRollupTransactorSession) PlaceStake(proof1 [][32]byte, proof2 [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.PlaceStake(&_ArbRollup.TransactOpts, proof1, proof2)
}

// PruneLeaf is a paid mutator transaction binding the contract method 0xef5f7cb9.
//
// Solidity: function pruneLeaf(bytes32 from, bytes32[] leafProof, bytes32[] latestConfirmedProof) returns()
func (_ArbRollup *ArbRollupTransactor) PruneLeaf(opts *bind.TransactOpts, from [32]byte, leafProof [][32]byte, latestConfirmedProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "pruneLeaf", from, leafProof, latestConfirmedProof)
}

// PruneLeaf is a paid mutator transaction binding the contract method 0xef5f7cb9.
//
// Solidity: function pruneLeaf(bytes32 from, bytes32[] leafProof, bytes32[] latestConfirmedProof) returns()
func (_ArbRollup *ArbRollupSession) PruneLeaf(from [32]byte, leafProof [][32]byte, latestConfirmedProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.PruneLeaf(&_ArbRollup.TransactOpts, from, leafProof, latestConfirmedProof)
}

// PruneLeaf is a paid mutator transaction binding the contract method 0xef5f7cb9.
//
// Solidity: function pruneLeaf(bytes32 from, bytes32[] leafProof, bytes32[] latestConfirmedProof) returns()
func (_ArbRollup *ArbRollupTransactorSession) PruneLeaf(from [32]byte, leafProof [][32]byte, latestConfirmedProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.PruneLeaf(&_ArbRollup.TransactOpts, from, leafProof, latestConfirmedProof)
}

// RecoverStakeConfirmed is a paid mutator transaction binding the contract method 0x7cfaaf67.
//
// Solidity: function recoverStakeConfirmed(bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactor) RecoverStakeConfirmed(opts *bind.TransactOpts, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "recoverStakeConfirmed", proof)
}

// RecoverStakeConfirmed is a paid mutator transaction binding the contract method 0x7cfaaf67.
//
// Solidity: function recoverStakeConfirmed(bytes32[] proof) returns()
func (_ArbRollup *ArbRollupSession) RecoverStakeConfirmed(proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeConfirmed(&_ArbRollup.TransactOpts, proof)
}

// RecoverStakeConfirmed is a paid mutator transaction binding the contract method 0x7cfaaf67.
//
// Solidity: function recoverStakeConfirmed(bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactorSession) RecoverStakeConfirmed(proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeConfirmed(&_ArbRollup.TransactOpts, proof)
}

// RecoverStakeMooted is a paid mutator transaction binding the contract method 0x33554032.
//
// Solidity: function recoverStakeMooted(address stakerAddress, bytes32 node, bytes32[] latestConfirmedProof, bytes32[] stakerProof) returns()
func (_ArbRollup *ArbRollupTransactor) RecoverStakeMooted(opts *bind.TransactOpts, stakerAddress common.Address, node [32]byte, latestConfirmedProof [][32]byte, stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "recoverStakeMooted", stakerAddress, node, latestConfirmedProof, stakerProof)
}

// RecoverStakeMooted is a paid mutator transaction binding the contract method 0x33554032.
//
// Solidity: function recoverStakeMooted(address stakerAddress, bytes32 node, bytes32[] latestConfirmedProof, bytes32[] stakerProof) returns()
func (_ArbRollup *ArbRollupSession) RecoverStakeMooted(stakerAddress common.Address, node [32]byte, latestConfirmedProof [][32]byte, stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeMooted(&_ArbRollup.TransactOpts, stakerAddress, node, latestConfirmedProof, stakerProof)
}

// RecoverStakeMooted is a paid mutator transaction binding the contract method 0x33554032.
//
// Solidity: function recoverStakeMooted(address stakerAddress, bytes32 node, bytes32[] latestConfirmedProof, bytes32[] stakerProof) returns()
func (_ArbRollup *ArbRollupTransactorSession) RecoverStakeMooted(stakerAddress common.Address, node [32]byte, latestConfirmedProof [][32]byte, stakerProof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeMooted(&_ArbRollup.TransactOpts, stakerAddress, node, latestConfirmedProof, stakerProof)
}

// RecoverStakeOld is a paid mutator transaction binding the contract method 0x113ec9d8.
//
// Solidity: function recoverStakeOld(address stakerAddress, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactor) RecoverStakeOld(opts *bind.TransactOpts, stakerAddress common.Address, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "recoverStakeOld", stakerAddress, proof)
}

// RecoverStakeOld is a paid mutator transaction binding the contract method 0x113ec9d8.
//
// Solidity: function recoverStakeOld(address stakerAddress, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupSession) RecoverStakeOld(stakerAddress common.Address, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeOld(&_ArbRollup.TransactOpts, stakerAddress, proof)
}

// RecoverStakeOld is a paid mutator transaction binding the contract method 0x113ec9d8.
//
// Solidity: function recoverStakeOld(address stakerAddress, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactorSession) RecoverStakeOld(stakerAddress common.Address, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakeOld(&_ArbRollup.TransactOpts, stakerAddress, proof)
}

// RecoverStakePassedDeadline is a paid mutator transaction binding the contract method 0xbadb3f14.
//
// Solidity: function recoverStakePassedDeadline(address stakerAddress, uint256 deadlineTicks, bytes32 disputableNodeHashVal, uint256 childType, bytes32 vmProtoStateHash, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactor) RecoverStakePassedDeadline(opts *bind.TransactOpts, stakerAddress common.Address, deadlineTicks *big.Int, disputableNodeHashVal [32]byte, childType *big.Int, vmProtoStateHash [32]byte, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "recoverStakePassedDeadline", stakerAddress, deadlineTicks, disputableNodeHashVal, childType, vmProtoStateHash, proof)
}

// RecoverStakePassedDeadline is a paid mutator transaction binding the contract method 0xbadb3f14.
//
// Solidity: function recoverStakePassedDeadline(address stakerAddress, uint256 deadlineTicks, bytes32 disputableNodeHashVal, uint256 childType, bytes32 vmProtoStateHash, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupSession) RecoverStakePassedDeadline(stakerAddress common.Address, deadlineTicks *big.Int, disputableNodeHashVal [32]byte, childType *big.Int, vmProtoStateHash [32]byte, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakePassedDeadline(&_ArbRollup.TransactOpts, stakerAddress, deadlineTicks, disputableNodeHashVal, childType, vmProtoStateHash, proof)
}

// RecoverStakePassedDeadline is a paid mutator transaction binding the contract method 0xbadb3f14.
//
// Solidity: function recoverStakePassedDeadline(address stakerAddress, uint256 deadlineTicks, bytes32 disputableNodeHashVal, uint256 childType, bytes32 vmProtoStateHash, bytes32[] proof) returns()
func (_ArbRollup *ArbRollupTransactorSession) RecoverStakePassedDeadline(stakerAddress common.Address, deadlineTicks *big.Int, disputableNodeHashVal [32]byte, childType *big.Int, vmProtoStateHash [32]byte, proof [][32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.RecoverStakePassedDeadline(&_ArbRollup.TransactOpts, stakerAddress, deadlineTicks, disputableNodeHashVal, childType, vmProtoStateHash, proof)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_ArbRollup *ArbRollupTransactor) ResolveChallenge(opts *bind.TransactOpts, winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "resolveChallenge", winner, loser, arg2)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_ArbRollup *ArbRollupSession) ResolveChallenge(winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.ResolveChallenge(&_ArbRollup.TransactOpts, winner, loser, arg2)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_ArbRollup *ArbRollupTransactorSession) ResolveChallenge(winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.ResolveChallenge(&_ArbRollup.TransactOpts, winner, loser, arg2)
}

// SnapshotDeadlineStakers is a paid mutator transaction binding the contract method 0x35fa6a6a.
//
// Solidity: function snapshotDeadlineStakers(uint256 idx, uint256 deadlineTicks, address[] beforeDeadlineAddrs, address[] atOrAfterDeadlineAddrs) returns()
func (_ArbRollup *ArbRollupTransactor) SnapshotDeadlineStakers(opts *bind.TransactOpts, idx *big.Int, deadlineTicks *big.Int, beforeDeadlineAddrs []common.Address, atOrAfterDeadlineAddrs []common.Address) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "snapshotDeadlineStakers", idx, deadlineTicks, beforeDeadlineAddrs, atOrAfterDeadlineAddrs)
}

// SnapshotDeadlineStakers is a paid mutator transaction binding the contract method 0x35fa6a6a.
//
// Solidity: function snapshotDeadlineStakers(uint256 idx, uint256 deadlineTicks, address[] beforeDeadlineAddrs, address[] atOrAfterDeadlineAddrs) returns()
func (_ArbRollup *ArbRollupSession) SnapshotDeadlineStakers(idx *big.Int, deadlineTicks *big.Int, beforeDeadlineAddrs []common.Address, atOrAfterDeadlineAddrs []common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.SnapshotDeadlineStakers(&_ArbRollup.TransactOpts, idx, deadlineTicks, beforeDeadlineAddrs, atOrAfterDeadlineAddrs)
}

// SnapshotDeadlineStakers is a paid mutator transaction binding the contract method 0x35fa6a6a.
//
// Solidity: function snapshotDeadlineStakers(uint256 idx, uint256 deadlineTicks, address[] beforeDeadlineAddrs, address[] atOrAfterDeadlineAddrs) returns()
func (_ArbRollup *ArbRollupTransactorSession) SnapshotDeadlineStakers(idx *big.Int, deadlineTicks *big.Int, beforeDeadlineAddrs []common.Address, atOrAfterDeadlineAddrs []common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.SnapshotDeadlineStakers(&_ArbRollup.TransactOpts, idx, deadlineTicks, beforeDeadlineAddrs, atOrAfterDeadlineAddrs)
}

// SnapshotLatestConfirmed is a paid mutator transaction binding the contract method 0x3dbcf76f.
//
// Solidity: function snapshotLatestConfirmed(uint256 idx) returns()
func (_ArbRollup *ArbRollupTransactor) SnapshotLatestConfirmed(opts *bind.TransactOpts, idx *big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "snapshotLatestConfirmed", idx)
}

// SnapshotLatestConfirmed is a paid mutator transaction binding the contract method 0x3dbcf76f.
//
// Solidity: function snapshotLatestConfirmed(uint256 idx) returns()
func (_ArbRollup *ArbRollupSession) SnapshotLatestConfirmed(idx *big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.SnapshotLatestConfirmed(&_ArbRollup.TransactOpts, idx)
}

// SnapshotLatestConfirmed is a paid mutator transaction binding the contract method 0x3dbcf76f.
//
// Solidity: function snapshotLatestConfirmed(uint256 idx) returns()
func (_ArbRollup *ArbRollupTransactorSession) SnapshotLatestConfirmed(idx *big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.SnapshotLatestConfirmed(&_ArbRollup.TransactOpts, idx)
}

// SnapshotLeafNodeExists is a paid mutator transaction binding the contract method 0x4cd525a1.
//
// Solidity: function snapshotLeafNodeExists(uint256 idx, bytes32 leaf) returns()
func (_ArbRollup *ArbRollupTransactor) SnapshotLeafNodeExists(opts *bind.TransactOpts, idx *big.Int, leaf [32]byte) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "snapshotLeafNodeExists", idx, leaf)
}

// SnapshotLeafNodeExists is a paid mutator transaction binding the contract method 0x4cd525a1.
//
// Solidity: function snapshotLeafNodeExists(uint256 idx, bytes32 leaf) returns()
func (_ArbRollup *ArbRollupSession) SnapshotLeafNodeExists(idx *big.Int, leaf [32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.SnapshotLeafNodeExists(&_ArbRollup.TransactOpts, idx, leaf)
}

// SnapshotLeafNodeExists is a paid mutator transaction binding the contract method 0x4cd525a1.
//
// Solidity: function snapshotLeafNodeExists(uint256 idx, bytes32 leaf) returns()
func (_ArbRollup *ArbRollupTransactorSession) SnapshotLeafNodeExists(idx *big.Int, leaf [32]byte) (*types.Transaction, error) {
	return _ArbRollup.Contract.SnapshotLeafNodeExists(&_ArbRollup.TransactOpts, idx, leaf)
}

// SnapshotStakerNodeExists is a paid mutator transaction binding the contract method 0xb7c83f3d.
//
// Solidity: function snapshotStakerNodeExists(uint256 idx, address addr) returns()
func (_ArbRollup *ArbRollupTransactor) SnapshotStakerNodeExists(opts *bind.TransactOpts, idx *big.Int, addr common.Address) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "snapshotStakerNodeExists", idx, addr)
}

// SnapshotStakerNodeExists is a paid mutator transaction binding the contract method 0xb7c83f3d.
//
// Solidity: function snapshotStakerNodeExists(uint256 idx, address addr) returns()
func (_ArbRollup *ArbRollupSession) SnapshotStakerNodeExists(idx *big.Int, addr common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.SnapshotStakerNodeExists(&_ArbRollup.TransactOpts, idx, addr)
}

// SnapshotStakerNodeExists is a paid mutator transaction binding the contract method 0xb7c83f3d.
//
// Solidity: function snapshotStakerNodeExists(uint256 idx, address addr) returns()
func (_ArbRollup *ArbRollupTransactorSession) SnapshotStakerNodeExists(idx *big.Int, addr common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.SnapshotStakerNodeExists(&_ArbRollup.TransactOpts, idx, addr)
}

// SnapshotTwoStakers is a paid mutator transaction binding the contract method 0x3cdb5dbe.
//
// Solidity: function snapshotTwoStakers(uint256 idx, address addr1, address addr2) returns()
func (_ArbRollup *ArbRollupTransactor) SnapshotTwoStakers(opts *bind.TransactOpts, idx *big.Int, addr1 common.Address, addr2 common.Address) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "snapshotTwoStakers", idx, addr1, addr2)
}

// SnapshotTwoStakers is a paid mutator transaction binding the contract method 0x3cdb5dbe.
//
// Solidity: function snapshotTwoStakers(uint256 idx, address addr1, address addr2) returns()
func (_ArbRollup *ArbRollupSession) SnapshotTwoStakers(idx *big.Int, addr1 common.Address, addr2 common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.SnapshotTwoStakers(&_ArbRollup.TransactOpts, idx, addr1, addr2)
}

// SnapshotTwoStakers is a paid mutator transaction binding the contract method 0x3cdb5dbe.
//
// Solidity: function snapshotTwoStakers(uint256 idx, address addr1, address addr2) returns()
func (_ArbRollup *ArbRollupTransactorSession) SnapshotTwoStakers(idx *big.Int, addr1 common.Address, addr2 common.Address) (*types.Transaction, error) {
	return _ArbRollup.Contract.SnapshotTwoStakers(&_ArbRollup.TransactOpts, idx, addr1, addr2)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_ArbRollup *ArbRollupTransactor) StartChallenge(opts *bind.TransactOpts, asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _ArbRollup.contract.Transact(opts, "startChallenge", asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_ArbRollup *ArbRollupSession) StartChallenge(asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.StartChallenge(&_ArbRollup.TransactOpts, asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_ArbRollup *ArbRollupTransactorSession) StartChallenge(asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _ArbRollup.Contract.StartChallenge(&_ArbRollup.TransactOpts, asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// ArbRollupConfirmedAssertionIterator is returned from FilterConfirmedAssertion and is used to iterate over the raw logs and unpacked data for ConfirmedAssertion events raised by the ArbRollup contract.
type ArbRollupConfirmedAssertionIterator struct {
	Event *ArbRollupConfirmedAssertion // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupConfirmedAssertionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupConfirmedAssertion)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupConfirmedAssertion)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupConfirmedAssertionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupConfirmedAssertionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupConfirmedAssertion represents a ConfirmedAssertion event raised by the ArbRollup contract.
type ArbRollupConfirmedAssertion struct {
	LogsAccHash [32]byte
	Raw         types.Log // Blockchain specific contextual infos
}

// FilterConfirmedAssertion is a free log retrieval operation binding the contract event 0x7c4ea4965dec519bdc58e57940c14ed469185c38f401798f2f38ed6d0afb1fd3.
//
// Solidity: event ConfirmedAssertion(bytes32 logsAccHash)
func (_ArbRollup *ArbRollupFilterer) FilterConfirmedAssertion(opts *bind.FilterOpts) (*ArbRollupConfirmedAssertionIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "ConfirmedAssertion")
	if err != nil {
		return nil, err
	}
	return &ArbRollupConfirmedAssertionIterator{contract: _ArbRollup.contract, event: "ConfirmedAssertion", logs: logs, sub: sub}, nil
}

// WatchConfirmedAssertion is a free log subscription operation binding the contract event 0x7c4ea4965dec519bdc58e57940c14ed469185c38f401798f2f38ed6d0afb1fd3.
//
// Solidity: event ConfirmedAssertion(bytes32 logsAccHash)
func (_ArbRollup *ArbRollupFilterer) WatchConfirmedAssertion(opts *bind.WatchOpts, sink chan<- *ArbRollupConfirmedAssertion) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "ConfirmedAssertion")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupConfirmedAssertion)
				if err := _ArbRollup.contract.UnpackLog(event, "ConfirmedAssertion", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseConfirmedAssertion is a log parse operation binding the contract event 0x7c4ea4965dec519bdc58e57940c14ed469185c38f401798f2f38ed6d0afb1fd3.
//
// Solidity: event ConfirmedAssertion(bytes32 logsAccHash)
func (_ArbRollup *ArbRollupFilterer) ParseConfirmedAssertion(log types.Log) (*ArbRollupConfirmedAssertion, error) {
	event := new(ArbRollupConfirmedAssertion)
	if err := _ArbRollup.contract.UnpackLog(event, "ConfirmedAssertion", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupAssertedIterator is returned from FilterRollupAsserted and is used to iterate over the raw logs and unpacked data for RollupAsserted events raised by the ArbRollup contract.
type ArbRollupRollupAssertedIterator struct {
	Event *ArbRollupRollupAsserted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupAssertedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupAsserted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupAsserted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupAssertedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupAssertedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupAsserted represents a RollupAsserted event raised by the ArbRollup contract.
type ArbRollupRollupAsserted struct {
	Fields               [7][32]byte
	PendingCount         *big.Int
	ImportedMessageCount *big.Int
	TimeBoundsBlocks     [2]*big.Int
	NumArbGas            uint64
	NumSteps             uint64
	DidInboxInsn         bool
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterRollupAsserted is a free log retrieval operation binding the contract event 0x5761ea2104e5d52e617adb7f0bfc8970ffa1d06f57d28cb2bb3a034532c97035.
//
// Solidity: event RollupAsserted(bytes32[7] fields, uint256 pendingCount, uint256 importedMessageCount, uint128[2] timeBoundsBlocks, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_ArbRollup *ArbRollupFilterer) FilterRollupAsserted(opts *bind.FilterOpts) (*ArbRollupRollupAssertedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupAsserted")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupAssertedIterator{contract: _ArbRollup.contract, event: "RollupAsserted", logs: logs, sub: sub}, nil
}

// WatchRollupAsserted is a free log subscription operation binding the contract event 0x5761ea2104e5d52e617adb7f0bfc8970ffa1d06f57d28cb2bb3a034532c97035.
//
// Solidity: event RollupAsserted(bytes32[7] fields, uint256 pendingCount, uint256 importedMessageCount, uint128[2] timeBoundsBlocks, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_ArbRollup *ArbRollupFilterer) WatchRollupAsserted(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupAsserted) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupAsserted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupAsserted)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupAsserted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupAsserted is a log parse operation binding the contract event 0x5761ea2104e5d52e617adb7f0bfc8970ffa1d06f57d28cb2bb3a034532c97035.
//
// Solidity: event RollupAsserted(bytes32[7] fields, uint256 pendingCount, uint256 importedMessageCount, uint128[2] timeBoundsBlocks, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_ArbRollup *ArbRollupFilterer) ParseRollupAsserted(log types.Log) (*ArbRollupRollupAsserted, error) {
	event := new(ArbRollupRollupAsserted)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupAsserted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupChallengeCompletedIterator is returned from FilterRollupChallengeCompleted and is used to iterate over the raw logs and unpacked data for RollupChallengeCompleted events raised by the ArbRollup contract.
type ArbRollupRollupChallengeCompletedIterator struct {
	Event *ArbRollupRollupChallengeCompleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupChallengeCompletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupChallengeCompleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupChallengeCompleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupChallengeCompletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupChallengeCompletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupChallengeCompleted represents a RollupChallengeCompleted event raised by the ArbRollup contract.
type ArbRollupRollupChallengeCompleted struct {
	ChallengeContract common.Address
	Winner            common.Address
	Loser             common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRollupChallengeCompleted is a free log retrieval operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_ArbRollup *ArbRollupFilterer) FilterRollupChallengeCompleted(opts *bind.FilterOpts) (*ArbRollupRollupChallengeCompletedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupChallengeCompleted")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupChallengeCompletedIterator{contract: _ArbRollup.contract, event: "RollupChallengeCompleted", logs: logs, sub: sub}, nil
}

// WatchRollupChallengeCompleted is a free log subscription operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_ArbRollup *ArbRollupFilterer) WatchRollupChallengeCompleted(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupChallengeCompleted) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupChallengeCompleted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupChallengeCompleted)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupChallengeCompleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupChallengeCompleted is a log parse operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_ArbRollup *ArbRollupFilterer) ParseRollupChallengeCompleted(log types.Log) (*ArbRollupRollupChallengeCompleted, error) {
	event := new(ArbRollupRollupChallengeCompleted)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupChallengeCompleted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupChallengeStartedIterator is returned from FilterRollupChallengeStarted and is used to iterate over the raw logs and unpacked data for RollupChallengeStarted events raised by the ArbRollup contract.
type ArbRollupRollupChallengeStartedIterator struct {
	Event *ArbRollupRollupChallengeStarted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupChallengeStartedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupChallengeStarted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupChallengeStarted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupChallengeStartedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupChallengeStartedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupChallengeStarted represents a RollupChallengeStarted event raised by the ArbRollup contract.
type ArbRollupRollupChallengeStarted struct {
	Asserter          common.Address
	Challenger        common.Address
	ChallengeType     *big.Int
	ChallengeContract common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRollupChallengeStarted is a free log retrieval operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_ArbRollup *ArbRollupFilterer) FilterRollupChallengeStarted(opts *bind.FilterOpts) (*ArbRollupRollupChallengeStartedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupChallengeStarted")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupChallengeStartedIterator{contract: _ArbRollup.contract, event: "RollupChallengeStarted", logs: logs, sub: sub}, nil
}

// WatchRollupChallengeStarted is a free log subscription operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_ArbRollup *ArbRollupFilterer) WatchRollupChallengeStarted(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupChallengeStarted) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupChallengeStarted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupChallengeStarted)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupChallengeStarted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupChallengeStarted is a log parse operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_ArbRollup *ArbRollupFilterer) ParseRollupChallengeStarted(log types.Log) (*ArbRollupRollupChallengeStarted, error) {
	event := new(ArbRollupRollupChallengeStarted)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupChallengeStarted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupConfirmedIterator is returned from FilterRollupConfirmed and is used to iterate over the raw logs and unpacked data for RollupConfirmed events raised by the ArbRollup contract.
type ArbRollupRollupConfirmedIterator struct {
	Event *ArbRollupRollupConfirmed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupConfirmedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupConfirmed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupConfirmed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupConfirmedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupConfirmedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupConfirmed represents a RollupConfirmed event raised by the ArbRollup contract.
type ArbRollupRollupConfirmed struct {
	NodeHash [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRollupConfirmed is a free log retrieval operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) FilterRollupConfirmed(opts *bind.FilterOpts) (*ArbRollupRollupConfirmedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupConfirmed")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupConfirmedIterator{contract: _ArbRollup.contract, event: "RollupConfirmed", logs: logs, sub: sub}, nil
}

// WatchRollupConfirmed is a free log subscription operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) WatchRollupConfirmed(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupConfirmed) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupConfirmed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupConfirmed)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupConfirmed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupConfirmed is a log parse operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) ParseRollupConfirmed(log types.Log) (*ArbRollupRollupConfirmed, error) {
	event := new(ArbRollupRollupConfirmed)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupConfirmed", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupCreatedIterator is returned from FilterRollupCreated and is used to iterate over the raw logs and unpacked data for RollupCreated events raised by the ArbRollup contract.
type ArbRollupRollupCreatedIterator struct {
	Event *ArbRollupRollupCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupCreated represents a RollupCreated event raised by the ArbRollup contract.
type ArbRollupRollupCreated struct {
	InitVMHash [32]byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterRollupCreated is a free log retrieval operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_ArbRollup *ArbRollupFilterer) FilterRollupCreated(opts *bind.FilterOpts) (*ArbRollupRollupCreatedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupCreated")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupCreatedIterator{contract: _ArbRollup.contract, event: "RollupCreated", logs: logs, sub: sub}, nil
}

// WatchRollupCreated is a free log subscription operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_ArbRollup *ArbRollupFilterer) WatchRollupCreated(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupCreated) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupCreated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupCreated)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupCreated is a log parse operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_ArbRollup *ArbRollupFilterer) ParseRollupCreated(log types.Log) (*ArbRollupRollupCreated, error) {
	event := new(ArbRollupRollupCreated)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupPrunedIterator is returned from FilterRollupPruned and is used to iterate over the raw logs and unpacked data for RollupPruned events raised by the ArbRollup contract.
type ArbRollupRollupPrunedIterator struct {
	Event *ArbRollupRollupPruned // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupPrunedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupPruned)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupPruned)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupPrunedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupPrunedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupPruned represents a RollupPruned event raised by the ArbRollup contract.
type ArbRollupRollupPruned struct {
	Leaf [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRollupPruned is a free log retrieval operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_ArbRollup *ArbRollupFilterer) FilterRollupPruned(opts *bind.FilterOpts) (*ArbRollupRollupPrunedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupPruned")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupPrunedIterator{contract: _ArbRollup.contract, event: "RollupPruned", logs: logs, sub: sub}, nil
}

// WatchRollupPruned is a free log subscription operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_ArbRollup *ArbRollupFilterer) WatchRollupPruned(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupPruned) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupPruned")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupPruned)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupPruned", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupPruned is a log parse operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_ArbRollup *ArbRollupFilterer) ParseRollupPruned(log types.Log) (*ArbRollupRollupPruned, error) {
	event := new(ArbRollupRollupPruned)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupPruned", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupStakeCreatedIterator is returned from FilterRollupStakeCreated and is used to iterate over the raw logs and unpacked data for RollupStakeCreated events raised by the ArbRollup contract.
type ArbRollupRollupStakeCreatedIterator struct {
	Event *ArbRollupRollupStakeCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupStakeCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupStakeCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupStakeCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupStakeCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupStakeCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupStakeCreated represents a RollupStakeCreated event raised by the ArbRollup contract.
type ArbRollupRollupStakeCreated struct {
	Staker   common.Address
	NodeHash [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeCreated is a free log retrieval operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) FilterRollupStakeCreated(opts *bind.FilterOpts) (*ArbRollupRollupStakeCreatedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupStakeCreated")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupStakeCreatedIterator{contract: _ArbRollup.contract, event: "RollupStakeCreated", logs: logs, sub: sub}, nil
}

// WatchRollupStakeCreated is a free log subscription operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) WatchRollupStakeCreated(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupStakeCreated) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupStakeCreated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupStakeCreated)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeCreated is a log parse operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_ArbRollup *ArbRollupFilterer) ParseRollupStakeCreated(log types.Log) (*ArbRollupRollupStakeCreated, error) {
	event := new(ArbRollupRollupStakeCreated)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupStakeMovedIterator is returned from FilterRollupStakeMoved and is used to iterate over the raw logs and unpacked data for RollupStakeMoved events raised by the ArbRollup contract.
type ArbRollupRollupStakeMovedIterator struct {
	Event *ArbRollupRollupStakeMoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupStakeMovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupStakeMoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupStakeMoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupStakeMovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupStakeMovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupStakeMoved represents a RollupStakeMoved event raised by the ArbRollup contract.
type ArbRollupRollupStakeMoved struct {
	Staker     common.Address
	ToNodeHash [32]byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeMoved is a free log retrieval operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_ArbRollup *ArbRollupFilterer) FilterRollupStakeMoved(opts *bind.FilterOpts) (*ArbRollupRollupStakeMovedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupStakeMoved")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupStakeMovedIterator{contract: _ArbRollup.contract, event: "RollupStakeMoved", logs: logs, sub: sub}, nil
}

// WatchRollupStakeMoved is a free log subscription operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_ArbRollup *ArbRollupFilterer) WatchRollupStakeMoved(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupStakeMoved) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupStakeMoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupStakeMoved)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeMoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeMoved is a log parse operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_ArbRollup *ArbRollupFilterer) ParseRollupStakeMoved(log types.Log) (*ArbRollupRollupStakeMoved, error) {
	event := new(ArbRollupRollupStakeMoved)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeMoved", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupRollupStakeRefundedIterator is returned from FilterRollupStakeRefunded and is used to iterate over the raw logs and unpacked data for RollupStakeRefunded events raised by the ArbRollup contract.
type ArbRollupRollupStakeRefundedIterator struct {
	Event *ArbRollupRollupStakeRefunded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupRollupStakeRefundedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupRollupStakeRefunded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupRollupStakeRefunded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupRollupStakeRefundedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupRollupStakeRefundedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupRollupStakeRefunded represents a RollupStakeRefunded event raised by the ArbRollup contract.
type ArbRollupRollupStakeRefunded struct {
	Staker common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeRefunded is a free log retrieval operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_ArbRollup *ArbRollupFilterer) FilterRollupStakeRefunded(opts *bind.FilterOpts) (*ArbRollupRollupStakeRefundedIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "RollupStakeRefunded")
	if err != nil {
		return nil, err
	}
	return &ArbRollupRollupStakeRefundedIterator{contract: _ArbRollup.contract, event: "RollupStakeRefunded", logs: logs, sub: sub}, nil
}

// WatchRollupStakeRefunded is a free log subscription operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_ArbRollup *ArbRollupFilterer) WatchRollupStakeRefunded(opts *bind.WatchOpts, sink chan<- *ArbRollupRollupStakeRefunded) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "RollupStakeRefunded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupRollupStakeRefunded)
				if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeRefunded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeRefunded is a log parse operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_ArbRollup *ArbRollupFilterer) ParseRollupStakeRefunded(log types.Log) (*ArbRollupRollupStakeRefunded, error) {
	event := new(ArbRollupRollupStakeRefunded)
	if err := _ArbRollup.contract.UnpackLog(event, "RollupStakeRefunded", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupSavedDeadlineStakersSnapshotIterator is returned from FilterSavedDeadlineStakersSnapshot and is used to iterate over the raw logs and unpacked data for SavedDeadlineStakersSnapshot events raised by the ArbRollup contract.
type ArbRollupSavedDeadlineStakersSnapshotIterator struct {
	Event *ArbRollupSavedDeadlineStakersSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupSavedDeadlineStakersSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupSavedDeadlineStakersSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupSavedDeadlineStakersSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupSavedDeadlineStakersSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupSavedDeadlineStakersSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupSavedDeadlineStakersSnapshot represents a SavedDeadlineStakersSnapshot event raised by the ArbRollup contract.
type ArbRollupSavedDeadlineStakersSnapshot struct {
	Client          common.Address
	DeadlineTicks   *big.Int
	StakerLocations [][32]byte
	Snapshot        [32]byte
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterSavedDeadlineStakersSnapshot is a free log retrieval operation binding the contract event 0x74ea644e404c0a911c3b4cceddbacb969cff8a6efc7efae69d1d9be45e6f1983.
//
// Solidity: event SavedDeadlineStakersSnapshot(address client, uint256 deadlineTicks, bytes32[] stakerLocations, bytes32 snapshot)
func (_ArbRollup *ArbRollupFilterer) FilterSavedDeadlineStakersSnapshot(opts *bind.FilterOpts) (*ArbRollupSavedDeadlineStakersSnapshotIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "SavedDeadlineStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return &ArbRollupSavedDeadlineStakersSnapshotIterator{contract: _ArbRollup.contract, event: "SavedDeadlineStakersSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedDeadlineStakersSnapshot is a free log subscription operation binding the contract event 0x74ea644e404c0a911c3b4cceddbacb969cff8a6efc7efae69d1d9be45e6f1983.
//
// Solidity: event SavedDeadlineStakersSnapshot(address client, uint256 deadlineTicks, bytes32[] stakerLocations, bytes32 snapshot)
func (_ArbRollup *ArbRollupFilterer) WatchSavedDeadlineStakersSnapshot(opts *bind.WatchOpts, sink chan<- *ArbRollupSavedDeadlineStakersSnapshot) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "SavedDeadlineStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupSavedDeadlineStakersSnapshot)
				if err := _ArbRollup.contract.UnpackLog(event, "SavedDeadlineStakersSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedDeadlineStakersSnapshot is a log parse operation binding the contract event 0x74ea644e404c0a911c3b4cceddbacb969cff8a6efc7efae69d1d9be45e6f1983.
//
// Solidity: event SavedDeadlineStakersSnapshot(address client, uint256 deadlineTicks, bytes32[] stakerLocations, bytes32 snapshot)
func (_ArbRollup *ArbRollupFilterer) ParseSavedDeadlineStakersSnapshot(log types.Log) (*ArbRollupSavedDeadlineStakersSnapshot, error) {
	event := new(ArbRollupSavedDeadlineStakersSnapshot)
	if err := _ArbRollup.contract.UnpackLog(event, "SavedDeadlineStakersSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupSavedLatestConfirmedSnapshotIterator is returned from FilterSavedLatestConfirmedSnapshot and is used to iterate over the raw logs and unpacked data for SavedLatestConfirmedSnapshot events raised by the ArbRollup contract.
type ArbRollupSavedLatestConfirmedSnapshotIterator struct {
	Event *ArbRollupSavedLatestConfirmedSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupSavedLatestConfirmedSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupSavedLatestConfirmedSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupSavedLatestConfirmedSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupSavedLatestConfirmedSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupSavedLatestConfirmedSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupSavedLatestConfirmedSnapshot represents a SavedLatestConfirmedSnapshot event raised by the ArbRollup contract.
type ArbRollupSavedLatestConfirmedSnapshot struct {
	Client          common.Address
	LatestConfirmed [32]byte
	Snapshot        [32]byte
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterSavedLatestConfirmedSnapshot is a free log retrieval operation binding the contract event 0x01e422abe4c07a9d56a7f67171e2f76848c67d632c74dcd3a5cbb50c63c22ca2.
//
// Solidity: event SavedLatestConfirmedSnapshot(address client, bytes32 latestConfirmed, bytes32 snapshot)
func (_ArbRollup *ArbRollupFilterer) FilterSavedLatestConfirmedSnapshot(opts *bind.FilterOpts) (*ArbRollupSavedLatestConfirmedSnapshotIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "SavedLatestConfirmedSnapshot")
	if err != nil {
		return nil, err
	}
	return &ArbRollupSavedLatestConfirmedSnapshotIterator{contract: _ArbRollup.contract, event: "SavedLatestConfirmedSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedLatestConfirmedSnapshot is a free log subscription operation binding the contract event 0x01e422abe4c07a9d56a7f67171e2f76848c67d632c74dcd3a5cbb50c63c22ca2.
//
// Solidity: event SavedLatestConfirmedSnapshot(address client, bytes32 latestConfirmed, bytes32 snapshot)
func (_ArbRollup *ArbRollupFilterer) WatchSavedLatestConfirmedSnapshot(opts *bind.WatchOpts, sink chan<- *ArbRollupSavedLatestConfirmedSnapshot) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "SavedLatestConfirmedSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupSavedLatestConfirmedSnapshot)
				if err := _ArbRollup.contract.UnpackLog(event, "SavedLatestConfirmedSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedLatestConfirmedSnapshot is a log parse operation binding the contract event 0x01e422abe4c07a9d56a7f67171e2f76848c67d632c74dcd3a5cbb50c63c22ca2.
//
// Solidity: event SavedLatestConfirmedSnapshot(address client, bytes32 latestConfirmed, bytes32 snapshot)
func (_ArbRollup *ArbRollupFilterer) ParseSavedLatestConfirmedSnapshot(log types.Log) (*ArbRollupSavedLatestConfirmedSnapshot, error) {
	event := new(ArbRollupSavedLatestConfirmedSnapshot)
	if err := _ArbRollup.contract.UnpackLog(event, "SavedLatestConfirmedSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupSavedNodeExistsSnapshotIterator is returned from FilterSavedNodeExistsSnapshot and is used to iterate over the raw logs and unpacked data for SavedNodeExistsSnapshot events raised by the ArbRollup contract.
type ArbRollupSavedNodeExistsSnapshotIterator struct {
	Event *ArbRollupSavedNodeExistsSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupSavedNodeExistsSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupSavedNodeExistsSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupSavedNodeExistsSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupSavedNodeExistsSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupSavedNodeExistsSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupSavedNodeExistsSnapshot represents a SavedNodeExistsSnapshot event raised by the ArbRollup contract.
type ArbRollupSavedNodeExistsSnapshot struct {
	Client   common.Address
	NodeHash [32]byte
	Snapshot [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterSavedNodeExistsSnapshot is a free log retrieval operation binding the contract event 0x98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556.
//
// Solidity: event SavedNodeExistsSnapshot(address client, bytes32 nodeHash, bytes32 snapshot)
func (_ArbRollup *ArbRollupFilterer) FilterSavedNodeExistsSnapshot(opts *bind.FilterOpts) (*ArbRollupSavedNodeExistsSnapshotIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "SavedNodeExistsSnapshot")
	if err != nil {
		return nil, err
	}
	return &ArbRollupSavedNodeExistsSnapshotIterator{contract: _ArbRollup.contract, event: "SavedNodeExistsSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedNodeExistsSnapshot is a free log subscription operation binding the contract event 0x98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556.
//
// Solidity: event SavedNodeExistsSnapshot(address client, bytes32 nodeHash, bytes32 snapshot)
func (_ArbRollup *ArbRollupFilterer) WatchSavedNodeExistsSnapshot(opts *bind.WatchOpts, sink chan<- *ArbRollupSavedNodeExistsSnapshot) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "SavedNodeExistsSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupSavedNodeExistsSnapshot)
				if err := _ArbRollup.contract.UnpackLog(event, "SavedNodeExistsSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedNodeExistsSnapshot is a log parse operation binding the contract event 0x98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556.
//
// Solidity: event SavedNodeExistsSnapshot(address client, bytes32 nodeHash, bytes32 snapshot)
func (_ArbRollup *ArbRollupFilterer) ParseSavedNodeExistsSnapshot(log types.Log) (*ArbRollupSavedNodeExistsSnapshot, error) {
	event := new(ArbRollupSavedNodeExistsSnapshot)
	if err := _ArbRollup.contract.UnpackLog(event, "SavedNodeExistsSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ArbRollupSavedTwoStakersSnapshotIterator is returned from FilterSavedTwoStakersSnapshot and is used to iterate over the raw logs and unpacked data for SavedTwoStakersSnapshot events raised by the ArbRollup contract.
type ArbRollupSavedTwoStakersSnapshotIterator struct {
	Event *ArbRollupSavedTwoStakersSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *ArbRollupSavedTwoStakersSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(ArbRollupSavedTwoStakersSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(ArbRollupSavedTwoStakersSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *ArbRollupSavedTwoStakersSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *ArbRollupSavedTwoStakersSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// ArbRollupSavedTwoStakersSnapshot represents a SavedTwoStakersSnapshot event raised by the ArbRollup contract.
type ArbRollupSavedTwoStakersSnapshot struct {
	Client    common.Address
	Addr1     common.Address
	Location1 [32]byte
	Addr2     common.Address
	Location2 [32]byte
	Snapshot  [32]byte
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterSavedTwoStakersSnapshot is a free log retrieval operation binding the contract event 0x18410fe1e6e0f23683d25f04192e6b95d64681eee6fc2abe5241d2f58cbfbe52.
//
// Solidity: event SavedTwoStakersSnapshot(address client, address addr1, bytes32 location1, address addr2, bytes32 location2, bytes32 snapshot)
func (_ArbRollup *ArbRollupFilterer) FilterSavedTwoStakersSnapshot(opts *bind.FilterOpts) (*ArbRollupSavedTwoStakersSnapshotIterator, error) {

	logs, sub, err := _ArbRollup.contract.FilterLogs(opts, "SavedTwoStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return &ArbRollupSavedTwoStakersSnapshotIterator{contract: _ArbRollup.contract, event: "SavedTwoStakersSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedTwoStakersSnapshot is a free log subscription operation binding the contract event 0x18410fe1e6e0f23683d25f04192e6b95d64681eee6fc2abe5241d2f58cbfbe52.
//
// Solidity: event SavedTwoStakersSnapshot(address client, address addr1, bytes32 location1, address addr2, bytes32 location2, bytes32 snapshot)
func (_ArbRollup *ArbRollupFilterer) WatchSavedTwoStakersSnapshot(opts *bind.WatchOpts, sink chan<- *ArbRollupSavedTwoStakersSnapshot) (event.Subscription, error) {

	logs, sub, err := _ArbRollup.contract.WatchLogs(opts, "SavedTwoStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(ArbRollupSavedTwoStakersSnapshot)
				if err := _ArbRollup.contract.UnpackLog(event, "SavedTwoStakersSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedTwoStakersSnapshot is a log parse operation binding the contract event 0x18410fe1e6e0f23683d25f04192e6b95d64681eee6fc2abe5241d2f58cbfbe52.
//
// Solidity: event SavedTwoStakersSnapshot(address client, address addr1, bytes32 location1, address addr2, bytes32 location2, bytes32 snapshot)
func (_ArbRollup *ArbRollupFilterer) ParseSavedTwoStakersSnapshot(log types.Log) (*ArbRollupSavedTwoStakersSnapshot, error) {
	event := new(ArbRollupSavedTwoStakersSnapshot)
	if err := _ArbRollup.contract.UnpackLog(event, "SavedTwoStakersSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// BytesLibABI is the input ABI used to generate the binding from.
const BytesLibABI = "[]"

// BytesLibBin is the compiled bytecode used for deploying new contracts.
var BytesLibBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a7231582055b137124f04de1ef717f921bbfad089e545a4e72b5922d7cb7dfaf33c4c961564736f6c63430005100032"

// DeployBytesLib deploys a new Ethereum contract, binding an instance of BytesLib to it.
func DeployBytesLib(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *BytesLib, error) {
	parsed, err := abi.JSON(strings.NewReader(BytesLibABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(BytesLibBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &BytesLib{BytesLibCaller: BytesLibCaller{contract: contract}, BytesLibTransactor: BytesLibTransactor{contract: contract}, BytesLibFilterer: BytesLibFilterer{contract: contract}}, nil
}

// BytesLib is an auto generated Go binding around an Ethereum contract.
type BytesLib struct {
	BytesLibCaller     // Read-only binding to the contract
	BytesLibTransactor // Write-only binding to the contract
	BytesLibFilterer   // Log filterer for contract events
}

// BytesLibCaller is an auto generated read-only Go binding around an Ethereum contract.
type BytesLibCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BytesLibTransactor is an auto generated write-only Go binding around an Ethereum contract.
type BytesLibTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BytesLibFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type BytesLibFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// BytesLibSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type BytesLibSession struct {
	Contract     *BytesLib         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// BytesLibCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type BytesLibCallerSession struct {
	Contract *BytesLibCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// BytesLibTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type BytesLibTransactorSession struct {
	Contract     *BytesLibTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// BytesLibRaw is an auto generated low-level Go binding around an Ethereum contract.
type BytesLibRaw struct {
	Contract *BytesLib // Generic contract binding to access the raw methods on
}

// BytesLibCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type BytesLibCallerRaw struct {
	Contract *BytesLibCaller // Generic read-only contract binding to access the raw methods on
}

// BytesLibTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type BytesLibTransactorRaw struct {
	Contract *BytesLibTransactor // Generic write-only contract binding to access the raw methods on
}

// NewBytesLib creates a new instance of BytesLib, bound to a specific deployed contract.
func NewBytesLib(address common.Address, backend bind.ContractBackend) (*BytesLib, error) {
	contract, err := bindBytesLib(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &BytesLib{BytesLibCaller: BytesLibCaller{contract: contract}, BytesLibTransactor: BytesLibTransactor{contract: contract}, BytesLibFilterer: BytesLibFilterer{contract: contract}}, nil
}

// NewBytesLibCaller creates a new read-only instance of BytesLib, bound to a specific deployed contract.
func NewBytesLibCaller(address common.Address, caller bind.ContractCaller) (*BytesLibCaller, error) {
	contract, err := bindBytesLib(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &BytesLibCaller{contract: contract}, nil
}

// NewBytesLibTransactor creates a new write-only instance of BytesLib, bound to a specific deployed contract.
func NewBytesLibTransactor(address common.Address, transactor bind.ContractTransactor) (*BytesLibTransactor, error) {
	contract, err := bindBytesLib(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &BytesLibTransactor{contract: contract}, nil
}

// NewBytesLibFilterer creates a new log filterer instance of BytesLib, bound to a specific deployed contract.
func NewBytesLibFilterer(address common.Address, filterer bind.ContractFilterer) (*BytesLibFilterer, error) {
	contract, err := bindBytesLib(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &BytesLibFilterer{contract: contract}, nil
}

// bindBytesLib binds a generic wrapper to an already deployed contract.
func bindBytesLib(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(BytesLibABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BytesLib *BytesLibRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BytesLib.Contract.BytesLibCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BytesLib *BytesLibRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BytesLib.Contract.BytesLibTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BytesLib *BytesLibRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BytesLib.Contract.BytesLibTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_BytesLib *BytesLibCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _BytesLib.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_BytesLib *BytesLibTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _BytesLib.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_BytesLib *BytesLibTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _BytesLib.Contract.contract.Transact(opts, method, params...)
}

// ChallengeTypeABI is the input ABI used to generate the binding from.
const ChallengeTypeABI = "[]"

// ChallengeTypeBin is the compiled bytecode used for deploying new contracts.
var ChallengeTypeBin = "0x6080604052348015600f57600080fd5b50603e80601d6000396000f3fe6080604052600080fdfea265627a7a7231582058d42af15e85caee18c57c12e0ed9b38dd59794f5870946783107902450dc3b264736f6c63430005100032"

// DeployChallengeType deploys a new Ethereum contract, binding an instance of ChallengeType to it.
func DeployChallengeType(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ChallengeType, error) {
	parsed, err := abi.JSON(strings.NewReader(ChallengeTypeABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ChallengeTypeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ChallengeType{ChallengeTypeCaller: ChallengeTypeCaller{contract: contract}, ChallengeTypeTransactor: ChallengeTypeTransactor{contract: contract}, ChallengeTypeFilterer: ChallengeTypeFilterer{contract: contract}}, nil
}

// ChallengeType is an auto generated Go binding around an Ethereum contract.
type ChallengeType struct {
	ChallengeTypeCaller     // Read-only binding to the contract
	ChallengeTypeTransactor // Write-only binding to the contract
	ChallengeTypeFilterer   // Log filterer for contract events
}

// ChallengeTypeCaller is an auto generated read-only Go binding around an Ethereum contract.
type ChallengeTypeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ChallengeTypeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ChallengeTypeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ChallengeTypeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ChallengeTypeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ChallengeTypeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ChallengeTypeSession struct {
	Contract     *ChallengeType    // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ChallengeTypeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ChallengeTypeCallerSession struct {
	Contract *ChallengeTypeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts        // Call options to use throughout this session
}

// ChallengeTypeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ChallengeTypeTransactorSession struct {
	Contract     *ChallengeTypeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts        // Transaction auth options to use throughout this session
}

// ChallengeTypeRaw is an auto generated low-level Go binding around an Ethereum contract.
type ChallengeTypeRaw struct {
	Contract *ChallengeType // Generic contract binding to access the raw methods on
}

// ChallengeTypeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ChallengeTypeCallerRaw struct {
	Contract *ChallengeTypeCaller // Generic read-only contract binding to access the raw methods on
}

// ChallengeTypeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ChallengeTypeTransactorRaw struct {
	Contract *ChallengeTypeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewChallengeType creates a new instance of ChallengeType, bound to a specific deployed contract.
func NewChallengeType(address common.Address, backend bind.ContractBackend) (*ChallengeType, error) {
	contract, err := bindChallengeType(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ChallengeType{ChallengeTypeCaller: ChallengeTypeCaller{contract: contract}, ChallengeTypeTransactor: ChallengeTypeTransactor{contract: contract}, ChallengeTypeFilterer: ChallengeTypeFilterer{contract: contract}}, nil
}

// NewChallengeTypeCaller creates a new read-only instance of ChallengeType, bound to a specific deployed contract.
func NewChallengeTypeCaller(address common.Address, caller bind.ContractCaller) (*ChallengeTypeCaller, error) {
	contract, err := bindChallengeType(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ChallengeTypeCaller{contract: contract}, nil
}

// NewChallengeTypeTransactor creates a new write-only instance of ChallengeType, bound to a specific deployed contract.
func NewChallengeTypeTransactor(address common.Address, transactor bind.ContractTransactor) (*ChallengeTypeTransactor, error) {
	contract, err := bindChallengeType(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ChallengeTypeTransactor{contract: contract}, nil
}

// NewChallengeTypeFilterer creates a new log filterer instance of ChallengeType, bound to a specific deployed contract.
func NewChallengeTypeFilterer(address common.Address, filterer bind.ContractFilterer) (*ChallengeTypeFilterer, error) {
	contract, err := bindChallengeType(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ChallengeTypeFilterer{contract: contract}, nil
}

// bindChallengeType binds a generic wrapper to an already deployed contract.
func bindChallengeType(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ChallengeTypeABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ChallengeType *ChallengeTypeRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ChallengeType.Contract.ChallengeTypeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ChallengeType *ChallengeTypeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ChallengeType.Contract.ChallengeTypeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ChallengeType *ChallengeTypeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ChallengeType.Contract.ChallengeTypeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ChallengeType *ChallengeTypeCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ChallengeType.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ChallengeType *ChallengeTypeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ChallengeType.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ChallengeType *ChallengeTypeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ChallengeType.Contract.contract.Transact(opts, method, params...)
}

// ChallengeUtilsABI is the input ABI used to generate the binding from.
const ChallengeUtilsABI = "[]"

// ChallengeUtilsBin is the compiled bytecode used for deploying new contracts.
var ChallengeUtilsBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820ddaf400af640a30d917ddf3e6315459f9dea1989cc461584d1a32789ea29eae864736f6c63430005100032"

// DeployChallengeUtils deploys a new Ethereum contract, binding an instance of ChallengeUtils to it.
func DeployChallengeUtils(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *ChallengeUtils, error) {
	parsed, err := abi.JSON(strings.NewReader(ChallengeUtilsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ChallengeUtilsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &ChallengeUtils{ChallengeUtilsCaller: ChallengeUtilsCaller{contract: contract}, ChallengeUtilsTransactor: ChallengeUtilsTransactor{contract: contract}, ChallengeUtilsFilterer: ChallengeUtilsFilterer{contract: contract}}, nil
}

// ChallengeUtils is an auto generated Go binding around an Ethereum contract.
type ChallengeUtils struct {
	ChallengeUtilsCaller     // Read-only binding to the contract
	ChallengeUtilsTransactor // Write-only binding to the contract
	ChallengeUtilsFilterer   // Log filterer for contract events
}

// ChallengeUtilsCaller is an auto generated read-only Go binding around an Ethereum contract.
type ChallengeUtilsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ChallengeUtilsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ChallengeUtilsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ChallengeUtilsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ChallengeUtilsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ChallengeUtilsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ChallengeUtilsSession struct {
	Contract     *ChallengeUtils   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ChallengeUtilsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ChallengeUtilsCallerSession struct {
	Contract *ChallengeUtilsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// ChallengeUtilsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ChallengeUtilsTransactorSession struct {
	Contract     *ChallengeUtilsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// ChallengeUtilsRaw is an auto generated low-level Go binding around an Ethereum contract.
type ChallengeUtilsRaw struct {
	Contract *ChallengeUtils // Generic contract binding to access the raw methods on
}

// ChallengeUtilsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ChallengeUtilsCallerRaw struct {
	Contract *ChallengeUtilsCaller // Generic read-only contract binding to access the raw methods on
}

// ChallengeUtilsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ChallengeUtilsTransactorRaw struct {
	Contract *ChallengeUtilsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewChallengeUtils creates a new instance of ChallengeUtils, bound to a specific deployed contract.
func NewChallengeUtils(address common.Address, backend bind.ContractBackend) (*ChallengeUtils, error) {
	contract, err := bindChallengeUtils(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &ChallengeUtils{ChallengeUtilsCaller: ChallengeUtilsCaller{contract: contract}, ChallengeUtilsTransactor: ChallengeUtilsTransactor{contract: contract}, ChallengeUtilsFilterer: ChallengeUtilsFilterer{contract: contract}}, nil
}

// NewChallengeUtilsCaller creates a new read-only instance of ChallengeUtils, bound to a specific deployed contract.
func NewChallengeUtilsCaller(address common.Address, caller bind.ContractCaller) (*ChallengeUtilsCaller, error) {
	contract, err := bindChallengeUtils(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ChallengeUtilsCaller{contract: contract}, nil
}

// NewChallengeUtilsTransactor creates a new write-only instance of ChallengeUtils, bound to a specific deployed contract.
func NewChallengeUtilsTransactor(address common.Address, transactor bind.ContractTransactor) (*ChallengeUtilsTransactor, error) {
	contract, err := bindChallengeUtils(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ChallengeUtilsTransactor{contract: contract}, nil
}

// NewChallengeUtilsFilterer creates a new log filterer instance of ChallengeUtils, bound to a specific deployed contract.
func NewChallengeUtilsFilterer(address common.Address, filterer bind.ContractFilterer) (*ChallengeUtilsFilterer, error) {
	contract, err := bindChallengeUtils(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ChallengeUtilsFilterer{contract: contract}, nil
}

// bindChallengeUtils binds a generic wrapper to an already deployed contract.
func bindChallengeUtils(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ChallengeUtilsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ChallengeUtils *ChallengeUtilsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ChallengeUtils.Contract.ChallengeUtilsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ChallengeUtils *ChallengeUtilsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ChallengeUtils.Contract.ChallengeUtilsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ChallengeUtils *ChallengeUtilsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ChallengeUtils.Contract.ChallengeUtilsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_ChallengeUtils *ChallengeUtilsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _ChallengeUtils.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_ChallengeUtils *ChallengeUtilsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _ChallengeUtils.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_ChallengeUtils *ChallengeUtilsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _ChallengeUtils.Contract.contract.Transact(opts, method, params...)
}

// IChallengeFactoryABI is the input ABI used to generate the binding from.
const IChallengeFactoryABI = "[{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"_asserter\",\"type\":\"address\"},{\"internalType\":\"addresspayable\",\"name\":\"_challenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_challengePeriodTicks\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_challengeHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"challengeType\",\"type\":\"uint256\"}],\"name\":\"createChallenge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"asserter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"challengeType\",\"type\":\"uint256\"}],\"name\":\"generateCloneAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// IChallengeFactoryFuncSigs maps the 4-byte function signature to its string representation.
var IChallengeFactoryFuncSigs = map[string]string{
	"865da1c2": "createChallenge(address,address,uint256,bytes32,uint256)",
	"729406c8": "generateCloneAddress(address,address,uint256)",
}

// IChallengeFactory is an auto generated Go binding around an Ethereum contract.
type IChallengeFactory struct {
	IChallengeFactoryCaller     // Read-only binding to the contract
	IChallengeFactoryTransactor // Write-only binding to the contract
	IChallengeFactoryFilterer   // Log filterer for contract events
}

// IChallengeFactoryCaller is an auto generated read-only Go binding around an Ethereum contract.
type IChallengeFactoryCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IChallengeFactoryTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IChallengeFactoryTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IChallengeFactoryFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IChallengeFactoryFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IChallengeFactorySession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IChallengeFactorySession struct {
	Contract     *IChallengeFactory // Generic contract binding to set the session for
	CallOpts     bind.CallOpts      // Call options to use throughout this session
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// IChallengeFactoryCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IChallengeFactoryCallerSession struct {
	Contract *IChallengeFactoryCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts            // Call options to use throughout this session
}

// IChallengeFactoryTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IChallengeFactoryTransactorSession struct {
	Contract     *IChallengeFactoryTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts            // Transaction auth options to use throughout this session
}

// IChallengeFactoryRaw is an auto generated low-level Go binding around an Ethereum contract.
type IChallengeFactoryRaw struct {
	Contract *IChallengeFactory // Generic contract binding to access the raw methods on
}

// IChallengeFactoryCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IChallengeFactoryCallerRaw struct {
	Contract *IChallengeFactoryCaller // Generic read-only contract binding to access the raw methods on
}

// IChallengeFactoryTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IChallengeFactoryTransactorRaw struct {
	Contract *IChallengeFactoryTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIChallengeFactory creates a new instance of IChallengeFactory, bound to a specific deployed contract.
func NewIChallengeFactory(address common.Address, backend bind.ContractBackend) (*IChallengeFactory, error) {
	contract, err := bindIChallengeFactory(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IChallengeFactory{IChallengeFactoryCaller: IChallengeFactoryCaller{contract: contract}, IChallengeFactoryTransactor: IChallengeFactoryTransactor{contract: contract}, IChallengeFactoryFilterer: IChallengeFactoryFilterer{contract: contract}}, nil
}

// NewIChallengeFactoryCaller creates a new read-only instance of IChallengeFactory, bound to a specific deployed contract.
func NewIChallengeFactoryCaller(address common.Address, caller bind.ContractCaller) (*IChallengeFactoryCaller, error) {
	contract, err := bindIChallengeFactory(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IChallengeFactoryCaller{contract: contract}, nil
}

// NewIChallengeFactoryTransactor creates a new write-only instance of IChallengeFactory, bound to a specific deployed contract.
func NewIChallengeFactoryTransactor(address common.Address, transactor bind.ContractTransactor) (*IChallengeFactoryTransactor, error) {
	contract, err := bindIChallengeFactory(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IChallengeFactoryTransactor{contract: contract}, nil
}

// NewIChallengeFactoryFilterer creates a new log filterer instance of IChallengeFactory, bound to a specific deployed contract.
func NewIChallengeFactoryFilterer(address common.Address, filterer bind.ContractFilterer) (*IChallengeFactoryFilterer, error) {
	contract, err := bindIChallengeFactory(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IChallengeFactoryFilterer{contract: contract}, nil
}

// bindIChallengeFactory binds a generic wrapper to an already deployed contract.
func bindIChallengeFactory(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IChallengeFactoryABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IChallengeFactory *IChallengeFactoryRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IChallengeFactory.Contract.IChallengeFactoryCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IChallengeFactory *IChallengeFactoryRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.IChallengeFactoryTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IChallengeFactory *IChallengeFactoryRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.IChallengeFactoryTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IChallengeFactory *IChallengeFactoryCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IChallengeFactory.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IChallengeFactory *IChallengeFactoryTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IChallengeFactory *IChallengeFactoryTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.contract.Transact(opts, method, params...)
}

// GenerateCloneAddress is a free data retrieval call binding the contract method 0x729406c8.
//
// Solidity: function generateCloneAddress(address asserter, address challenger, uint256 challengeType) constant returns(address)
func (_IChallengeFactory *IChallengeFactoryCaller) GenerateCloneAddress(opts *bind.CallOpts, asserter common.Address, challenger common.Address, challengeType *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _IChallengeFactory.contract.Call(opts, out, "generateCloneAddress", asserter, challenger, challengeType)
	return *ret0, err
}

// GenerateCloneAddress is a free data retrieval call binding the contract method 0x729406c8.
//
// Solidity: function generateCloneAddress(address asserter, address challenger, uint256 challengeType) constant returns(address)
func (_IChallengeFactory *IChallengeFactorySession) GenerateCloneAddress(asserter common.Address, challenger common.Address, challengeType *big.Int) (common.Address, error) {
	return _IChallengeFactory.Contract.GenerateCloneAddress(&_IChallengeFactory.CallOpts, asserter, challenger, challengeType)
}

// GenerateCloneAddress is a free data retrieval call binding the contract method 0x729406c8.
//
// Solidity: function generateCloneAddress(address asserter, address challenger, uint256 challengeType) constant returns(address)
func (_IChallengeFactory *IChallengeFactoryCallerSession) GenerateCloneAddress(asserter common.Address, challenger common.Address, challengeType *big.Int) (common.Address, error) {
	return _IChallengeFactory.Contract.GenerateCloneAddress(&_IChallengeFactory.CallOpts, asserter, challenger, challengeType)
}

// CreateChallenge is a paid mutator transaction binding the contract method 0x865da1c2.
//
// Solidity: function createChallenge(address _asserter, address _challenger, uint256 _challengePeriodTicks, bytes32 _challengeHash, uint256 challengeType) returns(address)
func (_IChallengeFactory *IChallengeFactoryTransactor) CreateChallenge(opts *bind.TransactOpts, _asserter common.Address, _challenger common.Address, _challengePeriodTicks *big.Int, _challengeHash [32]byte, challengeType *big.Int) (*types.Transaction, error) {
	return _IChallengeFactory.contract.Transact(opts, "createChallenge", _asserter, _challenger, _challengePeriodTicks, _challengeHash, challengeType)
}

// CreateChallenge is a paid mutator transaction binding the contract method 0x865da1c2.
//
// Solidity: function createChallenge(address _asserter, address _challenger, uint256 _challengePeriodTicks, bytes32 _challengeHash, uint256 challengeType) returns(address)
func (_IChallengeFactory *IChallengeFactorySession) CreateChallenge(_asserter common.Address, _challenger common.Address, _challengePeriodTicks *big.Int, _challengeHash [32]byte, challengeType *big.Int) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.CreateChallenge(&_IChallengeFactory.TransactOpts, _asserter, _challenger, _challengePeriodTicks, _challengeHash, challengeType)
}

// CreateChallenge is a paid mutator transaction binding the contract method 0x865da1c2.
//
// Solidity: function createChallenge(address _asserter, address _challenger, uint256 _challengePeriodTicks, bytes32 _challengeHash, uint256 challengeType) returns(address)
func (_IChallengeFactory *IChallengeFactoryTransactorSession) CreateChallenge(_asserter common.Address, _challenger common.Address, _challengePeriodTicks *big.Int, _challengeHash [32]byte, challengeType *big.Int) (*types.Transaction, error) {
	return _IChallengeFactory.Contract.CreateChallenge(&_IChallengeFactory.TransactOpts, _asserter, _challenger, _challengePeriodTicks, _challengeHash, challengeType)
}

// IGlobalPendingInboxABI is the input ABI used to generate the binding from.
const IGlobalPendingInboxABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"ERC20DepositMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc721\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"ERC721DepositMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"EthDepositMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"chain\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seqNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"TransactionMessageDelivered\",\"type\":\"event\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_erc20\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"depositERC20Message\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_erc721\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"depositERC721Message\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"depositEthMessage\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_seqNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"forwardTransactionMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getPending\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_messages\",\"type\":\"bytes\"}],\"name\":\"sendMessages\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_seqNumber\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"sendTransactionMessage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// IGlobalPendingInboxFuncSigs maps the 4-byte function signature to its string representation.
var IGlobalPendingInboxFuncSigs = map[string]string{
	"bca22b76": "depositERC20Message(address,address,address,uint256)",
	"8b7010aa": "depositERC721Message(address,address,address,uint256)",
	"5bd21290": "depositEthMessage(address,address)",
	"8bef8df0": "forwardTransactionMessage(address,address,uint256,uint256,bytes,bytes)",
	"11ae9ed2": "getPending()",
	"e4eb8c63": "sendMessages(bytes)",
	"8f5ed73e": "sendTransactionMessage(address,address,uint256,uint256,bytes)",
}

// IGlobalPendingInbox is an auto generated Go binding around an Ethereum contract.
type IGlobalPendingInbox struct {
	IGlobalPendingInboxCaller     // Read-only binding to the contract
	IGlobalPendingInboxTransactor // Write-only binding to the contract
	IGlobalPendingInboxFilterer   // Log filterer for contract events
}

// IGlobalPendingInboxCaller is an auto generated read-only Go binding around an Ethereum contract.
type IGlobalPendingInboxCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IGlobalPendingInboxTransactor is an auto generated write-only Go binding around an Ethereum contract.
type IGlobalPendingInboxTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IGlobalPendingInboxFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type IGlobalPendingInboxFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// IGlobalPendingInboxSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type IGlobalPendingInboxSession struct {
	Contract     *IGlobalPendingInbox // Generic contract binding to set the session for
	CallOpts     bind.CallOpts        // Call options to use throughout this session
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// IGlobalPendingInboxCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type IGlobalPendingInboxCallerSession struct {
	Contract *IGlobalPendingInboxCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts              // Call options to use throughout this session
}

// IGlobalPendingInboxTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type IGlobalPendingInboxTransactorSession struct {
	Contract     *IGlobalPendingInboxTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts              // Transaction auth options to use throughout this session
}

// IGlobalPendingInboxRaw is an auto generated low-level Go binding around an Ethereum contract.
type IGlobalPendingInboxRaw struct {
	Contract *IGlobalPendingInbox // Generic contract binding to access the raw methods on
}

// IGlobalPendingInboxCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type IGlobalPendingInboxCallerRaw struct {
	Contract *IGlobalPendingInboxCaller // Generic read-only contract binding to access the raw methods on
}

// IGlobalPendingInboxTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type IGlobalPendingInboxTransactorRaw struct {
	Contract *IGlobalPendingInboxTransactor // Generic write-only contract binding to access the raw methods on
}

// NewIGlobalPendingInbox creates a new instance of IGlobalPendingInbox, bound to a specific deployed contract.
func NewIGlobalPendingInbox(address common.Address, backend bind.ContractBackend) (*IGlobalPendingInbox, error) {
	contract, err := bindIGlobalPendingInbox(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &IGlobalPendingInbox{IGlobalPendingInboxCaller: IGlobalPendingInboxCaller{contract: contract}, IGlobalPendingInboxTransactor: IGlobalPendingInboxTransactor{contract: contract}, IGlobalPendingInboxFilterer: IGlobalPendingInboxFilterer{contract: contract}}, nil
}

// NewIGlobalPendingInboxCaller creates a new read-only instance of IGlobalPendingInbox, bound to a specific deployed contract.
func NewIGlobalPendingInboxCaller(address common.Address, caller bind.ContractCaller) (*IGlobalPendingInboxCaller, error) {
	contract, err := bindIGlobalPendingInbox(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &IGlobalPendingInboxCaller{contract: contract}, nil
}

// NewIGlobalPendingInboxTransactor creates a new write-only instance of IGlobalPendingInbox, bound to a specific deployed contract.
func NewIGlobalPendingInboxTransactor(address common.Address, transactor bind.ContractTransactor) (*IGlobalPendingInboxTransactor, error) {
	contract, err := bindIGlobalPendingInbox(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &IGlobalPendingInboxTransactor{contract: contract}, nil
}

// NewIGlobalPendingInboxFilterer creates a new log filterer instance of IGlobalPendingInbox, bound to a specific deployed contract.
func NewIGlobalPendingInboxFilterer(address common.Address, filterer bind.ContractFilterer) (*IGlobalPendingInboxFilterer, error) {
	contract, err := bindIGlobalPendingInbox(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &IGlobalPendingInboxFilterer{contract: contract}, nil
}

// bindIGlobalPendingInbox binds a generic wrapper to an already deployed contract.
func bindIGlobalPendingInbox(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(IGlobalPendingInboxABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IGlobalPendingInbox *IGlobalPendingInboxRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IGlobalPendingInbox.Contract.IGlobalPendingInboxCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IGlobalPendingInbox *IGlobalPendingInboxRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.IGlobalPendingInboxTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IGlobalPendingInbox *IGlobalPendingInboxRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.IGlobalPendingInboxTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_IGlobalPendingInbox *IGlobalPendingInboxCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _IGlobalPendingInbox.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.contract.Transact(opts, method, params...)
}

// DepositERC20Message is a paid mutator transaction binding the contract method 0xbca22b76.
//
// Solidity: function depositERC20Message(address _chain, address _to, address _erc20, uint256 _value) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactor) DepositERC20Message(opts *bind.TransactOpts, _chain common.Address, _to common.Address, _erc20 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalPendingInbox.contract.Transact(opts, "depositERC20Message", _chain, _to, _erc20, _value)
}

// DepositERC20Message is a paid mutator transaction binding the contract method 0xbca22b76.
//
// Solidity: function depositERC20Message(address _chain, address _to, address _erc20, uint256 _value) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxSession) DepositERC20Message(_chain common.Address, _to common.Address, _erc20 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.DepositERC20Message(&_IGlobalPendingInbox.TransactOpts, _chain, _to, _erc20, _value)
}

// DepositERC20Message is a paid mutator transaction binding the contract method 0xbca22b76.
//
// Solidity: function depositERC20Message(address _chain, address _to, address _erc20, uint256 _value) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactorSession) DepositERC20Message(_chain common.Address, _to common.Address, _erc20 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.DepositERC20Message(&_IGlobalPendingInbox.TransactOpts, _chain, _to, _erc20, _value)
}

// DepositERC721Message is a paid mutator transaction binding the contract method 0x8b7010aa.
//
// Solidity: function depositERC721Message(address _chain, address _to, address _erc721, uint256 _value) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactor) DepositERC721Message(opts *bind.TransactOpts, _chain common.Address, _to common.Address, _erc721 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalPendingInbox.contract.Transact(opts, "depositERC721Message", _chain, _to, _erc721, _value)
}

// DepositERC721Message is a paid mutator transaction binding the contract method 0x8b7010aa.
//
// Solidity: function depositERC721Message(address _chain, address _to, address _erc721, uint256 _value) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxSession) DepositERC721Message(_chain common.Address, _to common.Address, _erc721 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.DepositERC721Message(&_IGlobalPendingInbox.TransactOpts, _chain, _to, _erc721, _value)
}

// DepositERC721Message is a paid mutator transaction binding the contract method 0x8b7010aa.
//
// Solidity: function depositERC721Message(address _chain, address _to, address _erc721, uint256 _value) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactorSession) DepositERC721Message(_chain common.Address, _to common.Address, _erc721 common.Address, _value *big.Int) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.DepositERC721Message(&_IGlobalPendingInbox.TransactOpts, _chain, _to, _erc721, _value)
}

// DepositEthMessage is a paid mutator transaction binding the contract method 0x5bd21290.
//
// Solidity: function depositEthMessage(address _chain, address _to) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactor) DepositEthMessage(opts *bind.TransactOpts, _chain common.Address, _to common.Address) (*types.Transaction, error) {
	return _IGlobalPendingInbox.contract.Transact(opts, "depositEthMessage", _chain, _to)
}

// DepositEthMessage is a paid mutator transaction binding the contract method 0x5bd21290.
//
// Solidity: function depositEthMessage(address _chain, address _to) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxSession) DepositEthMessage(_chain common.Address, _to common.Address) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.DepositEthMessage(&_IGlobalPendingInbox.TransactOpts, _chain, _to)
}

// DepositEthMessage is a paid mutator transaction binding the contract method 0x5bd21290.
//
// Solidity: function depositEthMessage(address _chain, address _to) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactorSession) DepositEthMessage(_chain common.Address, _to common.Address) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.DepositEthMessage(&_IGlobalPendingInbox.TransactOpts, _chain, _to)
}

// ForwardTransactionMessage is a paid mutator transaction binding the contract method 0x8bef8df0.
//
// Solidity: function forwardTransactionMessage(address _chain, address _to, uint256 _seqNumber, uint256 _value, bytes _data, bytes _signature) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactor) ForwardTransactionMessage(opts *bind.TransactOpts, _chain common.Address, _to common.Address, _seqNumber *big.Int, _value *big.Int, _data []byte, _signature []byte) (*types.Transaction, error) {
	return _IGlobalPendingInbox.contract.Transact(opts, "forwardTransactionMessage", _chain, _to, _seqNumber, _value, _data, _signature)
}

// ForwardTransactionMessage is a paid mutator transaction binding the contract method 0x8bef8df0.
//
// Solidity: function forwardTransactionMessage(address _chain, address _to, uint256 _seqNumber, uint256 _value, bytes _data, bytes _signature) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxSession) ForwardTransactionMessage(_chain common.Address, _to common.Address, _seqNumber *big.Int, _value *big.Int, _data []byte, _signature []byte) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.ForwardTransactionMessage(&_IGlobalPendingInbox.TransactOpts, _chain, _to, _seqNumber, _value, _data, _signature)
}

// ForwardTransactionMessage is a paid mutator transaction binding the contract method 0x8bef8df0.
//
// Solidity: function forwardTransactionMessage(address _chain, address _to, uint256 _seqNumber, uint256 _value, bytes _data, bytes _signature) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactorSession) ForwardTransactionMessage(_chain common.Address, _to common.Address, _seqNumber *big.Int, _value *big.Int, _data []byte, _signature []byte) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.ForwardTransactionMessage(&_IGlobalPendingInbox.TransactOpts, _chain, _to, _seqNumber, _value, _data, _signature)
}

// GetPending is a paid mutator transaction binding the contract method 0x11ae9ed2.
//
// Solidity: function getPending() returns(bytes32, uint256)
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactor) GetPending(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _IGlobalPendingInbox.contract.Transact(opts, "getPending")
}

// GetPending is a paid mutator transaction binding the contract method 0x11ae9ed2.
//
// Solidity: function getPending() returns(bytes32, uint256)
func (_IGlobalPendingInbox *IGlobalPendingInboxSession) GetPending() (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.GetPending(&_IGlobalPendingInbox.TransactOpts)
}

// GetPending is a paid mutator transaction binding the contract method 0x11ae9ed2.
//
// Solidity: function getPending() returns(bytes32, uint256)
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactorSession) GetPending() (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.GetPending(&_IGlobalPendingInbox.TransactOpts)
}

// SendMessages is a paid mutator transaction binding the contract method 0xe4eb8c63.
//
// Solidity: function sendMessages(bytes _messages) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactor) SendMessages(opts *bind.TransactOpts, _messages []byte) (*types.Transaction, error) {
	return _IGlobalPendingInbox.contract.Transact(opts, "sendMessages", _messages)
}

// SendMessages is a paid mutator transaction binding the contract method 0xe4eb8c63.
//
// Solidity: function sendMessages(bytes _messages) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxSession) SendMessages(_messages []byte) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.SendMessages(&_IGlobalPendingInbox.TransactOpts, _messages)
}

// SendMessages is a paid mutator transaction binding the contract method 0xe4eb8c63.
//
// Solidity: function sendMessages(bytes _messages) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactorSession) SendMessages(_messages []byte) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.SendMessages(&_IGlobalPendingInbox.TransactOpts, _messages)
}

// SendTransactionMessage is a paid mutator transaction binding the contract method 0x8f5ed73e.
//
// Solidity: function sendTransactionMessage(address _chain, address _to, uint256 _seqNumber, uint256 _value, bytes _data) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactor) SendTransactionMessage(opts *bind.TransactOpts, _chain common.Address, _to common.Address, _seqNumber *big.Int, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalPendingInbox.contract.Transact(opts, "sendTransactionMessage", _chain, _to, _seqNumber, _value, _data)
}

// SendTransactionMessage is a paid mutator transaction binding the contract method 0x8f5ed73e.
//
// Solidity: function sendTransactionMessage(address _chain, address _to, uint256 _seqNumber, uint256 _value, bytes _data) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxSession) SendTransactionMessage(_chain common.Address, _to common.Address, _seqNumber *big.Int, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.SendTransactionMessage(&_IGlobalPendingInbox.TransactOpts, _chain, _to, _seqNumber, _value, _data)
}

// SendTransactionMessage is a paid mutator transaction binding the contract method 0x8f5ed73e.
//
// Solidity: function sendTransactionMessage(address _chain, address _to, uint256 _seqNumber, uint256 _value, bytes _data) returns()
func (_IGlobalPendingInbox *IGlobalPendingInboxTransactorSession) SendTransactionMessage(_chain common.Address, _to common.Address, _seqNumber *big.Int, _value *big.Int, _data []byte) (*types.Transaction, error) {
	return _IGlobalPendingInbox.Contract.SendTransactionMessage(&_IGlobalPendingInbox.TransactOpts, _chain, _to, _seqNumber, _value, _data)
}

// IGlobalPendingInboxERC20DepositMessageDeliveredIterator is returned from FilterERC20DepositMessageDelivered and is used to iterate over the raw logs and unpacked data for ERC20DepositMessageDelivered events raised by the IGlobalPendingInbox contract.
type IGlobalPendingInboxERC20DepositMessageDeliveredIterator struct {
	Event *IGlobalPendingInboxERC20DepositMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalPendingInboxERC20DepositMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalPendingInboxERC20DepositMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalPendingInboxERC20DepositMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalPendingInboxERC20DepositMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalPendingInboxERC20DepositMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalPendingInboxERC20DepositMessageDelivered represents a ERC20DepositMessageDelivered event raised by the IGlobalPendingInbox contract.
type IGlobalPendingInboxERC20DepositMessageDelivered struct {
	Chain      common.Address
	To         common.Address
	From       common.Address
	Erc20      common.Address
	Value      *big.Int
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterERC20DepositMessageDelivered is a free log retrieval operation binding the contract event 0xb13d04085b4a9f87fecfccf9b72081bb8a273498d6b08b4bccf2940d555b5e60.
//
// Solidity: event ERC20DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc20, uint256 value, uint256 messageNum)
func (_IGlobalPendingInbox *IGlobalPendingInboxFilterer) FilterERC20DepositMessageDelivered(opts *bind.FilterOpts, chain []common.Address, to []common.Address, from []common.Address) (*IGlobalPendingInboxERC20DepositMessageDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalPendingInbox.contract.FilterLogs(opts, "ERC20DepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalPendingInboxERC20DepositMessageDeliveredIterator{contract: _IGlobalPendingInbox.contract, event: "ERC20DepositMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchERC20DepositMessageDelivered is a free log subscription operation binding the contract event 0xb13d04085b4a9f87fecfccf9b72081bb8a273498d6b08b4bccf2940d555b5e60.
//
// Solidity: event ERC20DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc20, uint256 value, uint256 messageNum)
func (_IGlobalPendingInbox *IGlobalPendingInboxFilterer) WatchERC20DepositMessageDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalPendingInboxERC20DepositMessageDelivered, chain []common.Address, to []common.Address, from []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalPendingInbox.contract.WatchLogs(opts, "ERC20DepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalPendingInboxERC20DepositMessageDelivered)
				if err := _IGlobalPendingInbox.contract.UnpackLog(event, "ERC20DepositMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseERC20DepositMessageDelivered is a log parse operation binding the contract event 0xb13d04085b4a9f87fecfccf9b72081bb8a273498d6b08b4bccf2940d555b5e60.
//
// Solidity: event ERC20DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc20, uint256 value, uint256 messageNum)
func (_IGlobalPendingInbox *IGlobalPendingInboxFilterer) ParseERC20DepositMessageDelivered(log types.Log) (*IGlobalPendingInboxERC20DepositMessageDelivered, error) {
	event := new(IGlobalPendingInboxERC20DepositMessageDelivered)
	if err := _IGlobalPendingInbox.contract.UnpackLog(event, "ERC20DepositMessageDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IGlobalPendingInboxERC721DepositMessageDeliveredIterator is returned from FilterERC721DepositMessageDelivered and is used to iterate over the raw logs and unpacked data for ERC721DepositMessageDelivered events raised by the IGlobalPendingInbox contract.
type IGlobalPendingInboxERC721DepositMessageDeliveredIterator struct {
	Event *IGlobalPendingInboxERC721DepositMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalPendingInboxERC721DepositMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalPendingInboxERC721DepositMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalPendingInboxERC721DepositMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalPendingInboxERC721DepositMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalPendingInboxERC721DepositMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalPendingInboxERC721DepositMessageDelivered represents a ERC721DepositMessageDelivered event raised by the IGlobalPendingInbox contract.
type IGlobalPendingInboxERC721DepositMessageDelivered struct {
	Chain      common.Address
	To         common.Address
	From       common.Address
	Erc721     common.Address
	Id         *big.Int
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterERC721DepositMessageDelivered is a free log retrieval operation binding the contract event 0x40baf11a4a4a4be2a155dbf303fbaec6fabd52e267268bd7e3de4b4ed8a2e095.
//
// Solidity: event ERC721DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc721, uint256 id, uint256 messageNum)
func (_IGlobalPendingInbox *IGlobalPendingInboxFilterer) FilterERC721DepositMessageDelivered(opts *bind.FilterOpts, chain []common.Address, to []common.Address, from []common.Address) (*IGlobalPendingInboxERC721DepositMessageDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalPendingInbox.contract.FilterLogs(opts, "ERC721DepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalPendingInboxERC721DepositMessageDeliveredIterator{contract: _IGlobalPendingInbox.contract, event: "ERC721DepositMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchERC721DepositMessageDelivered is a free log subscription operation binding the contract event 0x40baf11a4a4a4be2a155dbf303fbaec6fabd52e267268bd7e3de4b4ed8a2e095.
//
// Solidity: event ERC721DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc721, uint256 id, uint256 messageNum)
func (_IGlobalPendingInbox *IGlobalPendingInboxFilterer) WatchERC721DepositMessageDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalPendingInboxERC721DepositMessageDelivered, chain []common.Address, to []common.Address, from []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalPendingInbox.contract.WatchLogs(opts, "ERC721DepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalPendingInboxERC721DepositMessageDelivered)
				if err := _IGlobalPendingInbox.contract.UnpackLog(event, "ERC721DepositMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseERC721DepositMessageDelivered is a log parse operation binding the contract event 0x40baf11a4a4a4be2a155dbf303fbaec6fabd52e267268bd7e3de4b4ed8a2e095.
//
// Solidity: event ERC721DepositMessageDelivered(address indexed chain, address indexed to, address indexed from, address erc721, uint256 id, uint256 messageNum)
func (_IGlobalPendingInbox *IGlobalPendingInboxFilterer) ParseERC721DepositMessageDelivered(log types.Log) (*IGlobalPendingInboxERC721DepositMessageDelivered, error) {
	event := new(IGlobalPendingInboxERC721DepositMessageDelivered)
	if err := _IGlobalPendingInbox.contract.UnpackLog(event, "ERC721DepositMessageDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IGlobalPendingInboxEthDepositMessageDeliveredIterator is returned from FilterEthDepositMessageDelivered and is used to iterate over the raw logs and unpacked data for EthDepositMessageDelivered events raised by the IGlobalPendingInbox contract.
type IGlobalPendingInboxEthDepositMessageDeliveredIterator struct {
	Event *IGlobalPendingInboxEthDepositMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalPendingInboxEthDepositMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalPendingInboxEthDepositMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalPendingInboxEthDepositMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalPendingInboxEthDepositMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalPendingInboxEthDepositMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalPendingInboxEthDepositMessageDelivered represents a EthDepositMessageDelivered event raised by the IGlobalPendingInbox contract.
type IGlobalPendingInboxEthDepositMessageDelivered struct {
	Chain      common.Address
	To         common.Address
	From       common.Address
	Value      *big.Int
	MessageNum *big.Int
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterEthDepositMessageDelivered is a free log retrieval operation binding the contract event 0xfd0d0553177fec183128f048fbde54554a3a67302f7ebd7f735215a358290705.
//
// Solidity: event EthDepositMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, uint256 messageNum)
func (_IGlobalPendingInbox *IGlobalPendingInboxFilterer) FilterEthDepositMessageDelivered(opts *bind.FilterOpts, chain []common.Address, to []common.Address, from []common.Address) (*IGlobalPendingInboxEthDepositMessageDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalPendingInbox.contract.FilterLogs(opts, "EthDepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalPendingInboxEthDepositMessageDeliveredIterator{contract: _IGlobalPendingInbox.contract, event: "EthDepositMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchEthDepositMessageDelivered is a free log subscription operation binding the contract event 0xfd0d0553177fec183128f048fbde54554a3a67302f7ebd7f735215a358290705.
//
// Solidity: event EthDepositMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, uint256 messageNum)
func (_IGlobalPendingInbox *IGlobalPendingInboxFilterer) WatchEthDepositMessageDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalPendingInboxEthDepositMessageDelivered, chain []common.Address, to []common.Address, from []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalPendingInbox.contract.WatchLogs(opts, "EthDepositMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalPendingInboxEthDepositMessageDelivered)
				if err := _IGlobalPendingInbox.contract.UnpackLog(event, "EthDepositMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseEthDepositMessageDelivered is a log parse operation binding the contract event 0xfd0d0553177fec183128f048fbde54554a3a67302f7ebd7f735215a358290705.
//
// Solidity: event EthDepositMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 value, uint256 messageNum)
func (_IGlobalPendingInbox *IGlobalPendingInboxFilterer) ParseEthDepositMessageDelivered(log types.Log) (*IGlobalPendingInboxEthDepositMessageDelivered, error) {
	event := new(IGlobalPendingInboxEthDepositMessageDelivered)
	if err := _IGlobalPendingInbox.contract.UnpackLog(event, "EthDepositMessageDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// IGlobalPendingInboxTransactionMessageDeliveredIterator is returned from FilterTransactionMessageDelivered and is used to iterate over the raw logs and unpacked data for TransactionMessageDelivered events raised by the IGlobalPendingInbox contract.
type IGlobalPendingInboxTransactionMessageDeliveredIterator struct {
	Event *IGlobalPendingInboxTransactionMessageDelivered // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *IGlobalPendingInboxTransactionMessageDeliveredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(IGlobalPendingInboxTransactionMessageDelivered)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(IGlobalPendingInboxTransactionMessageDelivered)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *IGlobalPendingInboxTransactionMessageDeliveredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *IGlobalPendingInboxTransactionMessageDeliveredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// IGlobalPendingInboxTransactionMessageDelivered represents a TransactionMessageDelivered event raised by the IGlobalPendingInbox contract.
type IGlobalPendingInboxTransactionMessageDelivered struct {
	Chain     common.Address
	To        common.Address
	From      common.Address
	SeqNumber *big.Int
	Value     *big.Int
	Data      []byte
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterTransactionMessageDelivered is a free log retrieval operation binding the contract event 0xcf612c95e8993eca9c6e0be96b26b47022996db601dc12b4cf68ec37829d87b3.
//
// Solidity: event TransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 seqNumber, uint256 value, bytes data)
func (_IGlobalPendingInbox *IGlobalPendingInboxFilterer) FilterTransactionMessageDelivered(opts *bind.FilterOpts, chain []common.Address, to []common.Address, from []common.Address) (*IGlobalPendingInboxTransactionMessageDeliveredIterator, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalPendingInbox.contract.FilterLogs(opts, "TransactionMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return &IGlobalPendingInboxTransactionMessageDeliveredIterator{contract: _IGlobalPendingInbox.contract, event: "TransactionMessageDelivered", logs: logs, sub: sub}, nil
}

// WatchTransactionMessageDelivered is a free log subscription operation binding the contract event 0xcf612c95e8993eca9c6e0be96b26b47022996db601dc12b4cf68ec37829d87b3.
//
// Solidity: event TransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 seqNumber, uint256 value, bytes data)
func (_IGlobalPendingInbox *IGlobalPendingInboxFilterer) WatchTransactionMessageDelivered(opts *bind.WatchOpts, sink chan<- *IGlobalPendingInboxTransactionMessageDelivered, chain []common.Address, to []common.Address, from []common.Address) (event.Subscription, error) {

	var chainRule []interface{}
	for _, chainItem := range chain {
		chainRule = append(chainRule, chainItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}
	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _IGlobalPendingInbox.contract.WatchLogs(opts, "TransactionMessageDelivered", chainRule, toRule, fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(IGlobalPendingInboxTransactionMessageDelivered)
				if err := _IGlobalPendingInbox.contract.UnpackLog(event, "TransactionMessageDelivered", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransactionMessageDelivered is a log parse operation binding the contract event 0xcf612c95e8993eca9c6e0be96b26b47022996db601dc12b4cf68ec37829d87b3.
//
// Solidity: event TransactionMessageDelivered(address indexed chain, address indexed to, address indexed from, uint256 seqNumber, uint256 value, bytes data)
func (_IGlobalPendingInbox *IGlobalPendingInboxFilterer) ParseTransactionMessageDelivered(log types.Log) (*IGlobalPendingInboxTransactionMessageDelivered, error) {
	event := new(IGlobalPendingInboxTransactionMessageDelivered)
	if err := _IGlobalPendingInbox.contract.UnpackLog(event, "TransactionMessageDelivered", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphABI is the input ABI used to generate the binding from.
const NodeGraphABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32[7]\",\"name\":\"fields\",\"type\":\"bytes32[7]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pendingCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"importedMessageCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128[2]\",\"name\":\"timeBoundsBlocks\",\"type\":\"uint128[2]\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"numArbGas\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"numSteps\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"didInboxInsn\",\"type\":\"bool\"}],\"name\":\"RollupAsserted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"initVMHash\",\"type\":\"bytes32\"}],\"name\":\"RollupCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"RollupPruned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"stakerLocations\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedDeadlineStakersSnapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"latestConfirmed\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedLatestConfirmedSnapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedNodeExistsSnapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"location1\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"location2\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedTwoStakersSnapshot\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getMySnapshot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalInbox\",\"outputs\":[{\"internalType\":\"contractIGlobalPendingInbox\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"isValidLeaf\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestConfirmed\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"from\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"leafProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"latestConfirmedProof\",\"type\":\"bytes32[]\"}],\"name\":\"pruneLeaf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"snapshotLatestConfirmed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"}],\"name\":\"snapshotLeafNodeExists\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vmParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gracePeriodTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"arbGasSpeedLimitPerTick\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"maxExecutionSteps\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// NodeGraphFuncSigs maps the 4-byte function signature to its string representation.
var NodeGraphFuncSigs = map[string]string{
	"c3f8ae34": "getMySnapshot(uint256)",
	"d489113a": "globalInbox()",
	"57ca6d1b": "isValidLeaf(bytes32)",
	"65f7f80d": "latestConfirmed()",
	"ef5f7cb9": "pruneLeaf(bytes32,bytes32[],bytes32[])",
	"3dbcf76f": "snapshotLatestConfirmed(uint256)",
	"4cd525a1": "snapshotLeafNodeExists(uint256,bytes32)",
	"bbc2cc00": "vmParams()",
}

// NodeGraphBin is the compiled bytecode used for deploying new contracts.
var NodeGraphBin = "0x608060405234801561001057600080fd5b506106f5806100206000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063bbc2cc001161005b578063bbc2cc001461011a578063c3f8ae341461014a578063d489113a14610167578063ef5f7cb91461018b57610088565b80633dbcf76f1461008d5780634cd525a1146100ac57806357ca6d1b146100cf57806365f7f80d14610100575b600080fd5b6100aa600480360360208110156100a357600080fd5b5035610254565b005b6100aa600480360360408110156100c257600080fd5b5080359060200135610263565b6100ec600480360360208110156100e557600080fd5b5035610283565b604080519115158252519081900360200190f35b610108610298565b60408051918252519081900360200190f35b61012261029e565b60408051938452602084019290925267ffffffffffffffff1682820152519081900360600190f35b6101086004803603602081101561016057600080fd5b50356102b4565b61016f6102cf565b604080516001600160a01b039092168252519081900360200190f35b6100aa600480360360608110156101a157600080fd5b813591908101906040810160208201356401000000008111156101c357600080fd5b8201836020820111156101d557600080fd5b803590602001918460208302840111640100000000831117156101f757600080fd5b91939092909160208101903564010000000081111561021557600080fd5b82018360208201111561022757600080fd5b8035906020019184602083028401116401000000008311171561024957600080fd5b5090925090506102de565b61026081600654610514565b50565b61026c81610283565b61027557600080fd5b61027f828261057f565b5050565b60009081526005602052604090205460ff1690565b60065490565b60025460035460045467ffffffffffffffff1683565b33600090815260208181526040808320938352929052205490565b6001546001600160a01b031681565b600061031d868686808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152506105ea92505050565b905061032881610283565b6040518060400160405280600a81526020016928292aa722afa622a0a360b11b815250906103d45760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b83811015610399578181015183820152602001610381565b50505050905090810190601f1680156103c65780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b50828260008181106103e257fe5b90506020020135858560008181106103f657fe5b905060200201351415801561044d575061040e610298565b61044b878585808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152506105ea92505050565b145b6040518060400160405280600e81526020016d141495539157d0d3d391931250d560921b815250906104c05760405162461bcd60e51b8152602060048201818152835160248401528351909283926044909101919085019080838360008315610399578181015183820152602001610381565b50600081815260056020908152604091829020805460ff19169055815183815291517f3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f44909509281900390910190a1505050505050565b600061051f82610601565b3360008181526020818152604080832088845282529182902084905581519283528201859052818101839052519192507f01e422abe4c07a9d56a7f67171e2f76848c67d632c74dcd3a5cbb50c63c22ca2919081900360600190a1505050565b600061058a82610643565b3360008181526020818152604080832088845282529182902084905581519283528201859052818101839052519192507f98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556919081900360600190a1505050565b60006105fa838360008551610658565b9392505050565b6040516000908190839060200180835b60ff1660f81b815260010182815260200192505050604051602081830303815290604052805190602001209050919050565b60405160009060039083906020018083610611565b600084835b838110156106b6578186828151811061067257fe5b60200260200101516040516020018083815260200182815260200192505050604051602081830303815290604052805190602001209150808060010191505061065d565b509594505050505056fea265627a7a72315820287d02fb5975c241e076be90c0a2fccdcb742e4dfdda3b82321217c888e1810064736f6c63430005100032"

// DeployNodeGraph deploys a new Ethereum contract, binding an instance of NodeGraph to it.
func DeployNodeGraph(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *NodeGraph, error) {
	parsed, err := abi.JSON(strings.NewReader(NodeGraphABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(NodeGraphBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &NodeGraph{NodeGraphCaller: NodeGraphCaller{contract: contract}, NodeGraphTransactor: NodeGraphTransactor{contract: contract}, NodeGraphFilterer: NodeGraphFilterer{contract: contract}}, nil
}

// NodeGraph is an auto generated Go binding around an Ethereum contract.
type NodeGraph struct {
	NodeGraphCaller     // Read-only binding to the contract
	NodeGraphTransactor // Write-only binding to the contract
	NodeGraphFilterer   // Log filterer for contract events
}

// NodeGraphCaller is an auto generated read-only Go binding around an Ethereum contract.
type NodeGraphCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphTransactor is an auto generated write-only Go binding around an Ethereum contract.
type NodeGraphTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type NodeGraphFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// NodeGraphSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type NodeGraphSession struct {
	Contract     *NodeGraph        // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// NodeGraphCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type NodeGraphCallerSession struct {
	Contract *NodeGraphCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts    // Call options to use throughout this session
}

// NodeGraphTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type NodeGraphTransactorSession struct {
	Contract     *NodeGraphTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts    // Transaction auth options to use throughout this session
}

// NodeGraphRaw is an auto generated low-level Go binding around an Ethereum contract.
type NodeGraphRaw struct {
	Contract *NodeGraph // Generic contract binding to access the raw methods on
}

// NodeGraphCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type NodeGraphCallerRaw struct {
	Contract *NodeGraphCaller // Generic read-only contract binding to access the raw methods on
}

// NodeGraphTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type NodeGraphTransactorRaw struct {
	Contract *NodeGraphTransactor // Generic write-only contract binding to access the raw methods on
}

// NewNodeGraph creates a new instance of NodeGraph, bound to a specific deployed contract.
func NewNodeGraph(address common.Address, backend bind.ContractBackend) (*NodeGraph, error) {
	contract, err := bindNodeGraph(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &NodeGraph{NodeGraphCaller: NodeGraphCaller{contract: contract}, NodeGraphTransactor: NodeGraphTransactor{contract: contract}, NodeGraphFilterer: NodeGraphFilterer{contract: contract}}, nil
}

// NewNodeGraphCaller creates a new read-only instance of NodeGraph, bound to a specific deployed contract.
func NewNodeGraphCaller(address common.Address, caller bind.ContractCaller) (*NodeGraphCaller, error) {
	contract, err := bindNodeGraph(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &NodeGraphCaller{contract: contract}, nil
}

// NewNodeGraphTransactor creates a new write-only instance of NodeGraph, bound to a specific deployed contract.
func NewNodeGraphTransactor(address common.Address, transactor bind.ContractTransactor) (*NodeGraphTransactor, error) {
	contract, err := bindNodeGraph(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &NodeGraphTransactor{contract: contract}, nil
}

// NewNodeGraphFilterer creates a new log filterer instance of NodeGraph, bound to a specific deployed contract.
func NewNodeGraphFilterer(address common.Address, filterer bind.ContractFilterer) (*NodeGraphFilterer, error) {
	contract, err := bindNodeGraph(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &NodeGraphFilterer{contract: contract}, nil
}

// bindNodeGraph binds a generic wrapper to an already deployed contract.
func bindNodeGraph(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(NodeGraphABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_NodeGraph *NodeGraphRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _NodeGraph.Contract.NodeGraphCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_NodeGraph *NodeGraphRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _NodeGraph.Contract.NodeGraphTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_NodeGraph *NodeGraphRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _NodeGraph.Contract.NodeGraphTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_NodeGraph *NodeGraphCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _NodeGraph.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_NodeGraph *NodeGraphTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _NodeGraph.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_NodeGraph *NodeGraphTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _NodeGraph.Contract.contract.Transact(opts, method, params...)
}

// GetMySnapshot is a free data retrieval call binding the contract method 0xc3f8ae34.
//
// Solidity: function getMySnapshot(uint256 idx) constant returns(bytes32)
func (_NodeGraph *NodeGraphCaller) GetMySnapshot(opts *bind.CallOpts, idx *big.Int) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _NodeGraph.contract.Call(opts, out, "getMySnapshot", idx)
	return *ret0, err
}

// GetMySnapshot is a free data retrieval call binding the contract method 0xc3f8ae34.
//
// Solidity: function getMySnapshot(uint256 idx) constant returns(bytes32)
func (_NodeGraph *NodeGraphSession) GetMySnapshot(idx *big.Int) ([32]byte, error) {
	return _NodeGraph.Contract.GetMySnapshot(&_NodeGraph.CallOpts, idx)
}

// GetMySnapshot is a free data retrieval call binding the contract method 0xc3f8ae34.
//
// Solidity: function getMySnapshot(uint256 idx) constant returns(bytes32)
func (_NodeGraph *NodeGraphCallerSession) GetMySnapshot(idx *big.Int) ([32]byte, error) {
	return _NodeGraph.Contract.GetMySnapshot(&_NodeGraph.CallOpts, idx)
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() constant returns(address)
func (_NodeGraph *NodeGraphCaller) GlobalInbox(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _NodeGraph.contract.Call(opts, out, "globalInbox")
	return *ret0, err
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() constant returns(address)
func (_NodeGraph *NodeGraphSession) GlobalInbox() (common.Address, error) {
	return _NodeGraph.Contract.GlobalInbox(&_NodeGraph.CallOpts)
}

// GlobalInbox is a free data retrieval call binding the contract method 0xd489113a.
//
// Solidity: function globalInbox() constant returns(address)
func (_NodeGraph *NodeGraphCallerSession) GlobalInbox() (common.Address, error) {
	return _NodeGraph.Contract.GlobalInbox(&_NodeGraph.CallOpts)
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) constant returns(bool)
func (_NodeGraph *NodeGraphCaller) IsValidLeaf(opts *bind.CallOpts, leaf [32]byte) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _NodeGraph.contract.Call(opts, out, "isValidLeaf", leaf)
	return *ret0, err
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) constant returns(bool)
func (_NodeGraph *NodeGraphSession) IsValidLeaf(leaf [32]byte) (bool, error) {
	return _NodeGraph.Contract.IsValidLeaf(&_NodeGraph.CallOpts, leaf)
}

// IsValidLeaf is a free data retrieval call binding the contract method 0x57ca6d1b.
//
// Solidity: function isValidLeaf(bytes32 leaf) constant returns(bool)
func (_NodeGraph *NodeGraphCallerSession) IsValidLeaf(leaf [32]byte) (bool, error) {
	return _NodeGraph.Contract.IsValidLeaf(&_NodeGraph.CallOpts, leaf)
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() constant returns(bytes32)
func (_NodeGraph *NodeGraphCaller) LatestConfirmed(opts *bind.CallOpts) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _NodeGraph.contract.Call(opts, out, "latestConfirmed")
	return *ret0, err
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() constant returns(bytes32)
func (_NodeGraph *NodeGraphSession) LatestConfirmed() ([32]byte, error) {
	return _NodeGraph.Contract.LatestConfirmed(&_NodeGraph.CallOpts)
}

// LatestConfirmed is a free data retrieval call binding the contract method 0x65f7f80d.
//
// Solidity: function latestConfirmed() constant returns(bytes32)
func (_NodeGraph *NodeGraphCallerSession) LatestConfirmed() ([32]byte, error) {
	return _NodeGraph.Contract.LatestConfirmed(&_NodeGraph.CallOpts)
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() constant returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps)
func (_NodeGraph *NodeGraphCaller) VmParams(opts *bind.CallOpts) (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
}, error) {
	ret := new(struct {
		GracePeriodTicks        *big.Int
		ArbGasSpeedLimitPerTick *big.Int
		MaxExecutionSteps       uint64
	})
	out := ret
	err := _NodeGraph.contract.Call(opts, out, "vmParams")
	return *ret, err
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() constant returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps)
func (_NodeGraph *NodeGraphSession) VmParams() (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
}, error) {
	return _NodeGraph.Contract.VmParams(&_NodeGraph.CallOpts)
}

// VmParams is a free data retrieval call binding the contract method 0xbbc2cc00.
//
// Solidity: function vmParams() constant returns(uint256 gracePeriodTicks, uint256 arbGasSpeedLimitPerTick, uint64 maxExecutionSteps)
func (_NodeGraph *NodeGraphCallerSession) VmParams() (struct {
	GracePeriodTicks        *big.Int
	ArbGasSpeedLimitPerTick *big.Int
	MaxExecutionSteps       uint64
}, error) {
	return _NodeGraph.Contract.VmParams(&_NodeGraph.CallOpts)
}

// PruneLeaf is a paid mutator transaction binding the contract method 0xef5f7cb9.
//
// Solidity: function pruneLeaf(bytes32 from, bytes32[] leafProof, bytes32[] latestConfirmedProof) returns()
func (_NodeGraph *NodeGraphTransactor) PruneLeaf(opts *bind.TransactOpts, from [32]byte, leafProof [][32]byte, latestConfirmedProof [][32]byte) (*types.Transaction, error) {
	return _NodeGraph.contract.Transact(opts, "pruneLeaf", from, leafProof, latestConfirmedProof)
}

// PruneLeaf is a paid mutator transaction binding the contract method 0xef5f7cb9.
//
// Solidity: function pruneLeaf(bytes32 from, bytes32[] leafProof, bytes32[] latestConfirmedProof) returns()
func (_NodeGraph *NodeGraphSession) PruneLeaf(from [32]byte, leafProof [][32]byte, latestConfirmedProof [][32]byte) (*types.Transaction, error) {
	return _NodeGraph.Contract.PruneLeaf(&_NodeGraph.TransactOpts, from, leafProof, latestConfirmedProof)
}

// PruneLeaf is a paid mutator transaction binding the contract method 0xef5f7cb9.
//
// Solidity: function pruneLeaf(bytes32 from, bytes32[] leafProof, bytes32[] latestConfirmedProof) returns()
func (_NodeGraph *NodeGraphTransactorSession) PruneLeaf(from [32]byte, leafProof [][32]byte, latestConfirmedProof [][32]byte) (*types.Transaction, error) {
	return _NodeGraph.Contract.PruneLeaf(&_NodeGraph.TransactOpts, from, leafProof, latestConfirmedProof)
}

// SnapshotLatestConfirmed is a paid mutator transaction binding the contract method 0x3dbcf76f.
//
// Solidity: function snapshotLatestConfirmed(uint256 idx) returns()
func (_NodeGraph *NodeGraphTransactor) SnapshotLatestConfirmed(opts *bind.TransactOpts, idx *big.Int) (*types.Transaction, error) {
	return _NodeGraph.contract.Transact(opts, "snapshotLatestConfirmed", idx)
}

// SnapshotLatestConfirmed is a paid mutator transaction binding the contract method 0x3dbcf76f.
//
// Solidity: function snapshotLatestConfirmed(uint256 idx) returns()
func (_NodeGraph *NodeGraphSession) SnapshotLatestConfirmed(idx *big.Int) (*types.Transaction, error) {
	return _NodeGraph.Contract.SnapshotLatestConfirmed(&_NodeGraph.TransactOpts, idx)
}

// SnapshotLatestConfirmed is a paid mutator transaction binding the contract method 0x3dbcf76f.
//
// Solidity: function snapshotLatestConfirmed(uint256 idx) returns()
func (_NodeGraph *NodeGraphTransactorSession) SnapshotLatestConfirmed(idx *big.Int) (*types.Transaction, error) {
	return _NodeGraph.Contract.SnapshotLatestConfirmed(&_NodeGraph.TransactOpts, idx)
}

// SnapshotLeafNodeExists is a paid mutator transaction binding the contract method 0x4cd525a1.
//
// Solidity: function snapshotLeafNodeExists(uint256 idx, bytes32 leaf) returns()
func (_NodeGraph *NodeGraphTransactor) SnapshotLeafNodeExists(opts *bind.TransactOpts, idx *big.Int, leaf [32]byte) (*types.Transaction, error) {
	return _NodeGraph.contract.Transact(opts, "snapshotLeafNodeExists", idx, leaf)
}

// SnapshotLeafNodeExists is a paid mutator transaction binding the contract method 0x4cd525a1.
//
// Solidity: function snapshotLeafNodeExists(uint256 idx, bytes32 leaf) returns()
func (_NodeGraph *NodeGraphSession) SnapshotLeafNodeExists(idx *big.Int, leaf [32]byte) (*types.Transaction, error) {
	return _NodeGraph.Contract.SnapshotLeafNodeExists(&_NodeGraph.TransactOpts, idx, leaf)
}

// SnapshotLeafNodeExists is a paid mutator transaction binding the contract method 0x4cd525a1.
//
// Solidity: function snapshotLeafNodeExists(uint256 idx, bytes32 leaf) returns()
func (_NodeGraph *NodeGraphTransactorSession) SnapshotLeafNodeExists(idx *big.Int, leaf [32]byte) (*types.Transaction, error) {
	return _NodeGraph.Contract.SnapshotLeafNodeExists(&_NodeGraph.TransactOpts, idx, leaf)
}

// NodeGraphRollupAssertedIterator is returned from FilterRollupAsserted and is used to iterate over the raw logs and unpacked data for RollupAsserted events raised by the NodeGraph contract.
type NodeGraphRollupAssertedIterator struct {
	Event *NodeGraphRollupAsserted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphRollupAssertedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphRollupAsserted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphRollupAsserted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphRollupAssertedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphRollupAssertedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphRollupAsserted represents a RollupAsserted event raised by the NodeGraph contract.
type NodeGraphRollupAsserted struct {
	Fields               [7][32]byte
	PendingCount         *big.Int
	ImportedMessageCount *big.Int
	TimeBoundsBlocks     [2]*big.Int
	NumArbGas            uint64
	NumSteps             uint64
	DidInboxInsn         bool
	Raw                  types.Log // Blockchain specific contextual infos
}

// FilterRollupAsserted is a free log retrieval operation binding the contract event 0x5761ea2104e5d52e617adb7f0bfc8970ffa1d06f57d28cb2bb3a034532c97035.
//
// Solidity: event RollupAsserted(bytes32[7] fields, uint256 pendingCount, uint256 importedMessageCount, uint128[2] timeBoundsBlocks, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_NodeGraph *NodeGraphFilterer) FilterRollupAsserted(opts *bind.FilterOpts) (*NodeGraphRollupAssertedIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "RollupAsserted")
	if err != nil {
		return nil, err
	}
	return &NodeGraphRollupAssertedIterator{contract: _NodeGraph.contract, event: "RollupAsserted", logs: logs, sub: sub}, nil
}

// WatchRollupAsserted is a free log subscription operation binding the contract event 0x5761ea2104e5d52e617adb7f0bfc8970ffa1d06f57d28cb2bb3a034532c97035.
//
// Solidity: event RollupAsserted(bytes32[7] fields, uint256 pendingCount, uint256 importedMessageCount, uint128[2] timeBoundsBlocks, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_NodeGraph *NodeGraphFilterer) WatchRollupAsserted(opts *bind.WatchOpts, sink chan<- *NodeGraphRollupAsserted) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "RollupAsserted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphRollupAsserted)
				if err := _NodeGraph.contract.UnpackLog(event, "RollupAsserted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupAsserted is a log parse operation binding the contract event 0x5761ea2104e5d52e617adb7f0bfc8970ffa1d06f57d28cb2bb3a034532c97035.
//
// Solidity: event RollupAsserted(bytes32[7] fields, uint256 pendingCount, uint256 importedMessageCount, uint128[2] timeBoundsBlocks, uint64 numArbGas, uint64 numSteps, bool didInboxInsn)
func (_NodeGraph *NodeGraphFilterer) ParseRollupAsserted(log types.Log) (*NodeGraphRollupAsserted, error) {
	event := new(NodeGraphRollupAsserted)
	if err := _NodeGraph.contract.UnpackLog(event, "RollupAsserted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphRollupConfirmedIterator is returned from FilterRollupConfirmed and is used to iterate over the raw logs and unpacked data for RollupConfirmed events raised by the NodeGraph contract.
type NodeGraphRollupConfirmedIterator struct {
	Event *NodeGraphRollupConfirmed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphRollupConfirmedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphRollupConfirmed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphRollupConfirmed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphRollupConfirmedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphRollupConfirmedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphRollupConfirmed represents a RollupConfirmed event raised by the NodeGraph contract.
type NodeGraphRollupConfirmed struct {
	NodeHash [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRollupConfirmed is a free log retrieval operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_NodeGraph *NodeGraphFilterer) FilterRollupConfirmed(opts *bind.FilterOpts) (*NodeGraphRollupConfirmedIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "RollupConfirmed")
	if err != nil {
		return nil, err
	}
	return &NodeGraphRollupConfirmedIterator{contract: _NodeGraph.contract, event: "RollupConfirmed", logs: logs, sub: sub}, nil
}

// WatchRollupConfirmed is a free log subscription operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_NodeGraph *NodeGraphFilterer) WatchRollupConfirmed(opts *bind.WatchOpts, sink chan<- *NodeGraphRollupConfirmed) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "RollupConfirmed")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphRollupConfirmed)
				if err := _NodeGraph.contract.UnpackLog(event, "RollupConfirmed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupConfirmed is a log parse operation binding the contract event 0x9d13d0ad532ca8e545a3b66828cb99a18c3bc98e2a50b4db1990a033fdba6f63.
//
// Solidity: event RollupConfirmed(bytes32 nodeHash)
func (_NodeGraph *NodeGraphFilterer) ParseRollupConfirmed(log types.Log) (*NodeGraphRollupConfirmed, error) {
	event := new(NodeGraphRollupConfirmed)
	if err := _NodeGraph.contract.UnpackLog(event, "RollupConfirmed", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphRollupCreatedIterator is returned from FilterRollupCreated and is used to iterate over the raw logs and unpacked data for RollupCreated events raised by the NodeGraph contract.
type NodeGraphRollupCreatedIterator struct {
	Event *NodeGraphRollupCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphRollupCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphRollupCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphRollupCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphRollupCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphRollupCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphRollupCreated represents a RollupCreated event raised by the NodeGraph contract.
type NodeGraphRollupCreated struct {
	InitVMHash [32]byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterRollupCreated is a free log retrieval operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_NodeGraph *NodeGraphFilterer) FilterRollupCreated(opts *bind.FilterOpts) (*NodeGraphRollupCreatedIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "RollupCreated")
	if err != nil {
		return nil, err
	}
	return &NodeGraphRollupCreatedIterator{contract: _NodeGraph.contract, event: "RollupCreated", logs: logs, sub: sub}, nil
}

// WatchRollupCreated is a free log subscription operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_NodeGraph *NodeGraphFilterer) WatchRollupCreated(opts *bind.WatchOpts, sink chan<- *NodeGraphRollupCreated) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "RollupCreated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphRollupCreated)
				if err := _NodeGraph.contract.UnpackLog(event, "RollupCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupCreated is a log parse operation binding the contract event 0x4ac0014773275a3dfb58c58539631006301de41998cce7c4f8698d297c88bb2d.
//
// Solidity: event RollupCreated(bytes32 initVMHash)
func (_NodeGraph *NodeGraphFilterer) ParseRollupCreated(log types.Log) (*NodeGraphRollupCreated, error) {
	event := new(NodeGraphRollupCreated)
	if err := _NodeGraph.contract.UnpackLog(event, "RollupCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphRollupPrunedIterator is returned from FilterRollupPruned and is used to iterate over the raw logs and unpacked data for RollupPruned events raised by the NodeGraph contract.
type NodeGraphRollupPrunedIterator struct {
	Event *NodeGraphRollupPruned // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphRollupPrunedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphRollupPruned)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphRollupPruned)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphRollupPrunedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphRollupPrunedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphRollupPruned represents a RollupPruned event raised by the NodeGraph contract.
type NodeGraphRollupPruned struct {
	Leaf [32]byte
	Raw  types.Log // Blockchain specific contextual infos
}

// FilterRollupPruned is a free log retrieval operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_NodeGraph *NodeGraphFilterer) FilterRollupPruned(opts *bind.FilterOpts) (*NodeGraphRollupPrunedIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "RollupPruned")
	if err != nil {
		return nil, err
	}
	return &NodeGraphRollupPrunedIterator{contract: _NodeGraph.contract, event: "RollupPruned", logs: logs, sub: sub}, nil
}

// WatchRollupPruned is a free log subscription operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_NodeGraph *NodeGraphFilterer) WatchRollupPruned(opts *bind.WatchOpts, sink chan<- *NodeGraphRollupPruned) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "RollupPruned")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphRollupPruned)
				if err := _NodeGraph.contract.UnpackLog(event, "RollupPruned", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupPruned is a log parse operation binding the contract event 0x3d3e2ada9638548d1bb115fd766ef675213d953efe8d433bbd8d6718f4490950.
//
// Solidity: event RollupPruned(bytes32 leaf)
func (_NodeGraph *NodeGraphFilterer) ParseRollupPruned(log types.Log) (*NodeGraphRollupPruned, error) {
	event := new(NodeGraphRollupPruned)
	if err := _NodeGraph.contract.UnpackLog(event, "RollupPruned", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphSavedDeadlineStakersSnapshotIterator is returned from FilterSavedDeadlineStakersSnapshot and is used to iterate over the raw logs and unpacked data for SavedDeadlineStakersSnapshot events raised by the NodeGraph contract.
type NodeGraphSavedDeadlineStakersSnapshotIterator struct {
	Event *NodeGraphSavedDeadlineStakersSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphSavedDeadlineStakersSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphSavedDeadlineStakersSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphSavedDeadlineStakersSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphSavedDeadlineStakersSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphSavedDeadlineStakersSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphSavedDeadlineStakersSnapshot represents a SavedDeadlineStakersSnapshot event raised by the NodeGraph contract.
type NodeGraphSavedDeadlineStakersSnapshot struct {
	Client          common.Address
	DeadlineTicks   *big.Int
	StakerLocations [][32]byte
	Snapshot        [32]byte
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterSavedDeadlineStakersSnapshot is a free log retrieval operation binding the contract event 0x74ea644e404c0a911c3b4cceddbacb969cff8a6efc7efae69d1d9be45e6f1983.
//
// Solidity: event SavedDeadlineStakersSnapshot(address client, uint256 deadlineTicks, bytes32[] stakerLocations, bytes32 snapshot)
func (_NodeGraph *NodeGraphFilterer) FilterSavedDeadlineStakersSnapshot(opts *bind.FilterOpts) (*NodeGraphSavedDeadlineStakersSnapshotIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "SavedDeadlineStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return &NodeGraphSavedDeadlineStakersSnapshotIterator{contract: _NodeGraph.contract, event: "SavedDeadlineStakersSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedDeadlineStakersSnapshot is a free log subscription operation binding the contract event 0x74ea644e404c0a911c3b4cceddbacb969cff8a6efc7efae69d1d9be45e6f1983.
//
// Solidity: event SavedDeadlineStakersSnapshot(address client, uint256 deadlineTicks, bytes32[] stakerLocations, bytes32 snapshot)
func (_NodeGraph *NodeGraphFilterer) WatchSavedDeadlineStakersSnapshot(opts *bind.WatchOpts, sink chan<- *NodeGraphSavedDeadlineStakersSnapshot) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "SavedDeadlineStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphSavedDeadlineStakersSnapshot)
				if err := _NodeGraph.contract.UnpackLog(event, "SavedDeadlineStakersSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedDeadlineStakersSnapshot is a log parse operation binding the contract event 0x74ea644e404c0a911c3b4cceddbacb969cff8a6efc7efae69d1d9be45e6f1983.
//
// Solidity: event SavedDeadlineStakersSnapshot(address client, uint256 deadlineTicks, bytes32[] stakerLocations, bytes32 snapshot)
func (_NodeGraph *NodeGraphFilterer) ParseSavedDeadlineStakersSnapshot(log types.Log) (*NodeGraphSavedDeadlineStakersSnapshot, error) {
	event := new(NodeGraphSavedDeadlineStakersSnapshot)
	if err := _NodeGraph.contract.UnpackLog(event, "SavedDeadlineStakersSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphSavedLatestConfirmedSnapshotIterator is returned from FilterSavedLatestConfirmedSnapshot and is used to iterate over the raw logs and unpacked data for SavedLatestConfirmedSnapshot events raised by the NodeGraph contract.
type NodeGraphSavedLatestConfirmedSnapshotIterator struct {
	Event *NodeGraphSavedLatestConfirmedSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphSavedLatestConfirmedSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphSavedLatestConfirmedSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphSavedLatestConfirmedSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphSavedLatestConfirmedSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphSavedLatestConfirmedSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphSavedLatestConfirmedSnapshot represents a SavedLatestConfirmedSnapshot event raised by the NodeGraph contract.
type NodeGraphSavedLatestConfirmedSnapshot struct {
	Client          common.Address
	LatestConfirmed [32]byte
	Snapshot        [32]byte
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterSavedLatestConfirmedSnapshot is a free log retrieval operation binding the contract event 0x01e422abe4c07a9d56a7f67171e2f76848c67d632c74dcd3a5cbb50c63c22ca2.
//
// Solidity: event SavedLatestConfirmedSnapshot(address client, bytes32 latestConfirmed, bytes32 snapshot)
func (_NodeGraph *NodeGraphFilterer) FilterSavedLatestConfirmedSnapshot(opts *bind.FilterOpts) (*NodeGraphSavedLatestConfirmedSnapshotIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "SavedLatestConfirmedSnapshot")
	if err != nil {
		return nil, err
	}
	return &NodeGraphSavedLatestConfirmedSnapshotIterator{contract: _NodeGraph.contract, event: "SavedLatestConfirmedSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedLatestConfirmedSnapshot is a free log subscription operation binding the contract event 0x01e422abe4c07a9d56a7f67171e2f76848c67d632c74dcd3a5cbb50c63c22ca2.
//
// Solidity: event SavedLatestConfirmedSnapshot(address client, bytes32 latestConfirmed, bytes32 snapshot)
func (_NodeGraph *NodeGraphFilterer) WatchSavedLatestConfirmedSnapshot(opts *bind.WatchOpts, sink chan<- *NodeGraphSavedLatestConfirmedSnapshot) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "SavedLatestConfirmedSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphSavedLatestConfirmedSnapshot)
				if err := _NodeGraph.contract.UnpackLog(event, "SavedLatestConfirmedSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedLatestConfirmedSnapshot is a log parse operation binding the contract event 0x01e422abe4c07a9d56a7f67171e2f76848c67d632c74dcd3a5cbb50c63c22ca2.
//
// Solidity: event SavedLatestConfirmedSnapshot(address client, bytes32 latestConfirmed, bytes32 snapshot)
func (_NodeGraph *NodeGraphFilterer) ParseSavedLatestConfirmedSnapshot(log types.Log) (*NodeGraphSavedLatestConfirmedSnapshot, error) {
	event := new(NodeGraphSavedLatestConfirmedSnapshot)
	if err := _NodeGraph.contract.UnpackLog(event, "SavedLatestConfirmedSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphSavedNodeExistsSnapshotIterator is returned from FilterSavedNodeExistsSnapshot and is used to iterate over the raw logs and unpacked data for SavedNodeExistsSnapshot events raised by the NodeGraph contract.
type NodeGraphSavedNodeExistsSnapshotIterator struct {
	Event *NodeGraphSavedNodeExistsSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphSavedNodeExistsSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphSavedNodeExistsSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphSavedNodeExistsSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphSavedNodeExistsSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphSavedNodeExistsSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphSavedNodeExistsSnapshot represents a SavedNodeExistsSnapshot event raised by the NodeGraph contract.
type NodeGraphSavedNodeExistsSnapshot struct {
	Client   common.Address
	NodeHash [32]byte
	Snapshot [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterSavedNodeExistsSnapshot is a free log retrieval operation binding the contract event 0x98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556.
//
// Solidity: event SavedNodeExistsSnapshot(address client, bytes32 nodeHash, bytes32 snapshot)
func (_NodeGraph *NodeGraphFilterer) FilterSavedNodeExistsSnapshot(opts *bind.FilterOpts) (*NodeGraphSavedNodeExistsSnapshotIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "SavedNodeExistsSnapshot")
	if err != nil {
		return nil, err
	}
	return &NodeGraphSavedNodeExistsSnapshotIterator{contract: _NodeGraph.contract, event: "SavedNodeExistsSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedNodeExistsSnapshot is a free log subscription operation binding the contract event 0x98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556.
//
// Solidity: event SavedNodeExistsSnapshot(address client, bytes32 nodeHash, bytes32 snapshot)
func (_NodeGraph *NodeGraphFilterer) WatchSavedNodeExistsSnapshot(opts *bind.WatchOpts, sink chan<- *NodeGraphSavedNodeExistsSnapshot) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "SavedNodeExistsSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphSavedNodeExistsSnapshot)
				if err := _NodeGraph.contract.UnpackLog(event, "SavedNodeExistsSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedNodeExistsSnapshot is a log parse operation binding the contract event 0x98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556.
//
// Solidity: event SavedNodeExistsSnapshot(address client, bytes32 nodeHash, bytes32 snapshot)
func (_NodeGraph *NodeGraphFilterer) ParseSavedNodeExistsSnapshot(log types.Log) (*NodeGraphSavedNodeExistsSnapshot, error) {
	event := new(NodeGraphSavedNodeExistsSnapshot)
	if err := _NodeGraph.contract.UnpackLog(event, "SavedNodeExistsSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// NodeGraphSavedTwoStakersSnapshotIterator is returned from FilterSavedTwoStakersSnapshot and is used to iterate over the raw logs and unpacked data for SavedTwoStakersSnapshot events raised by the NodeGraph contract.
type NodeGraphSavedTwoStakersSnapshotIterator struct {
	Event *NodeGraphSavedTwoStakersSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *NodeGraphSavedTwoStakersSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(NodeGraphSavedTwoStakersSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(NodeGraphSavedTwoStakersSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *NodeGraphSavedTwoStakersSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *NodeGraphSavedTwoStakersSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// NodeGraphSavedTwoStakersSnapshot represents a SavedTwoStakersSnapshot event raised by the NodeGraph contract.
type NodeGraphSavedTwoStakersSnapshot struct {
	Client    common.Address
	Addr1     common.Address
	Location1 [32]byte
	Addr2     common.Address
	Location2 [32]byte
	Snapshot  [32]byte
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterSavedTwoStakersSnapshot is a free log retrieval operation binding the contract event 0x18410fe1e6e0f23683d25f04192e6b95d64681eee6fc2abe5241d2f58cbfbe52.
//
// Solidity: event SavedTwoStakersSnapshot(address client, address addr1, bytes32 location1, address addr2, bytes32 location2, bytes32 snapshot)
func (_NodeGraph *NodeGraphFilterer) FilterSavedTwoStakersSnapshot(opts *bind.FilterOpts) (*NodeGraphSavedTwoStakersSnapshotIterator, error) {

	logs, sub, err := _NodeGraph.contract.FilterLogs(opts, "SavedTwoStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return &NodeGraphSavedTwoStakersSnapshotIterator{contract: _NodeGraph.contract, event: "SavedTwoStakersSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedTwoStakersSnapshot is a free log subscription operation binding the contract event 0x18410fe1e6e0f23683d25f04192e6b95d64681eee6fc2abe5241d2f58cbfbe52.
//
// Solidity: event SavedTwoStakersSnapshot(address client, address addr1, bytes32 location1, address addr2, bytes32 location2, bytes32 snapshot)
func (_NodeGraph *NodeGraphFilterer) WatchSavedTwoStakersSnapshot(opts *bind.WatchOpts, sink chan<- *NodeGraphSavedTwoStakersSnapshot) (event.Subscription, error) {

	logs, sub, err := _NodeGraph.contract.WatchLogs(opts, "SavedTwoStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(NodeGraphSavedTwoStakersSnapshot)
				if err := _NodeGraph.contract.UnpackLog(event, "SavedTwoStakersSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedTwoStakersSnapshot is a log parse operation binding the contract event 0x18410fe1e6e0f23683d25f04192e6b95d64681eee6fc2abe5241d2f58cbfbe52.
//
// Solidity: event SavedTwoStakersSnapshot(address client, address addr1, bytes32 location1, address addr2, bytes32 location2, bytes32 snapshot)
func (_NodeGraph *NodeGraphFilterer) ParseSavedTwoStakersSnapshot(log types.Log) (*NodeGraphSavedTwoStakersSnapshot, error) {
	event := new(NodeGraphSavedTwoStakersSnapshot)
	if err := _NodeGraph.contract.UnpackLog(event, "SavedTwoStakersSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// ProtocolABI is the input ABI used to generate the binding from.
const ProtocolABI = "[]"

// ProtocolBin is the compiled bytecode used for deploying new contracts.
var ProtocolBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820f289ca8133c9ba6c93086d1ccc39e2eae7e9c44b526500ab9c5a7f79079f158e64736f6c63430005100032"

// DeployProtocol deploys a new Ethereum contract, binding an instance of Protocol to it.
func DeployProtocol(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Protocol, error) {
	parsed, err := abi.JSON(strings.NewReader(ProtocolABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ProtocolBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Protocol{ProtocolCaller: ProtocolCaller{contract: contract}, ProtocolTransactor: ProtocolTransactor{contract: contract}, ProtocolFilterer: ProtocolFilterer{contract: contract}}, nil
}

// Protocol is an auto generated Go binding around an Ethereum contract.
type Protocol struct {
	ProtocolCaller     // Read-only binding to the contract
	ProtocolTransactor // Write-only binding to the contract
	ProtocolFilterer   // Log filterer for contract events
}

// ProtocolCaller is an auto generated read-only Go binding around an Ethereum contract.
type ProtocolCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ProtocolTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ProtocolTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ProtocolFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ProtocolFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ProtocolSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ProtocolSession struct {
	Contract     *Protocol         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ProtocolCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ProtocolCallerSession struct {
	Contract *ProtocolCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// ProtocolTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ProtocolTransactorSession struct {
	Contract     *ProtocolTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// ProtocolRaw is an auto generated low-level Go binding around an Ethereum contract.
type ProtocolRaw struct {
	Contract *Protocol // Generic contract binding to access the raw methods on
}

// ProtocolCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ProtocolCallerRaw struct {
	Contract *ProtocolCaller // Generic read-only contract binding to access the raw methods on
}

// ProtocolTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ProtocolTransactorRaw struct {
	Contract *ProtocolTransactor // Generic write-only contract binding to access the raw methods on
}

// NewProtocol creates a new instance of Protocol, bound to a specific deployed contract.
func NewProtocol(address common.Address, backend bind.ContractBackend) (*Protocol, error) {
	contract, err := bindProtocol(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Protocol{ProtocolCaller: ProtocolCaller{contract: contract}, ProtocolTransactor: ProtocolTransactor{contract: contract}, ProtocolFilterer: ProtocolFilterer{contract: contract}}, nil
}

// NewProtocolCaller creates a new read-only instance of Protocol, bound to a specific deployed contract.
func NewProtocolCaller(address common.Address, caller bind.ContractCaller) (*ProtocolCaller, error) {
	contract, err := bindProtocol(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ProtocolCaller{contract: contract}, nil
}

// NewProtocolTransactor creates a new write-only instance of Protocol, bound to a specific deployed contract.
func NewProtocolTransactor(address common.Address, transactor bind.ContractTransactor) (*ProtocolTransactor, error) {
	contract, err := bindProtocol(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ProtocolTransactor{contract: contract}, nil
}

// NewProtocolFilterer creates a new log filterer instance of Protocol, bound to a specific deployed contract.
func NewProtocolFilterer(address common.Address, filterer bind.ContractFilterer) (*ProtocolFilterer, error) {
	contract, err := bindProtocol(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ProtocolFilterer{contract: contract}, nil
}

// bindProtocol binds a generic wrapper to an already deployed contract.
func bindProtocol(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ProtocolABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Protocol *ProtocolRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Protocol.Contract.ProtocolCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Protocol *ProtocolRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Protocol.Contract.ProtocolTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Protocol *ProtocolRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Protocol.Contract.ProtocolTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Protocol *ProtocolCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Protocol.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Protocol *ProtocolTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Protocol.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Protocol *ProtocolTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Protocol.Contract.contract.Transact(opts, method, params...)
}

// RollupTimeABI is the input ABI used to generate the binding from.
const RollupTimeABI = "[]"

// RollupTimeBin is the compiled bytecode used for deploying new contracts.
var RollupTimeBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820567bd523c2a3835903bc4c15252e3f5047d94de05e366f7ab59d27a918b7780e64736f6c63430005100032"

// DeployRollupTime deploys a new Ethereum contract, binding an instance of RollupTime to it.
func DeployRollupTime(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *RollupTime, error) {
	parsed, err := abi.JSON(strings.NewReader(RollupTimeABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(RollupTimeBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &RollupTime{RollupTimeCaller: RollupTimeCaller{contract: contract}, RollupTimeTransactor: RollupTimeTransactor{contract: contract}, RollupTimeFilterer: RollupTimeFilterer{contract: contract}}, nil
}

// RollupTime is an auto generated Go binding around an Ethereum contract.
type RollupTime struct {
	RollupTimeCaller     // Read-only binding to the contract
	RollupTimeTransactor // Write-only binding to the contract
	RollupTimeFilterer   // Log filterer for contract events
}

// RollupTimeCaller is an auto generated read-only Go binding around an Ethereum contract.
type RollupTimeCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupTimeTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RollupTimeTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupTimeFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RollupTimeFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupTimeSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RollupTimeSession struct {
	Contract     *RollupTime       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RollupTimeCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RollupTimeCallerSession struct {
	Contract *RollupTimeCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// RollupTimeTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RollupTimeTransactorSession struct {
	Contract     *RollupTimeTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// RollupTimeRaw is an auto generated low-level Go binding around an Ethereum contract.
type RollupTimeRaw struct {
	Contract *RollupTime // Generic contract binding to access the raw methods on
}

// RollupTimeCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RollupTimeCallerRaw struct {
	Contract *RollupTimeCaller // Generic read-only contract binding to access the raw methods on
}

// RollupTimeTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RollupTimeTransactorRaw struct {
	Contract *RollupTimeTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRollupTime creates a new instance of RollupTime, bound to a specific deployed contract.
func NewRollupTime(address common.Address, backend bind.ContractBackend) (*RollupTime, error) {
	contract, err := bindRollupTime(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &RollupTime{RollupTimeCaller: RollupTimeCaller{contract: contract}, RollupTimeTransactor: RollupTimeTransactor{contract: contract}, RollupTimeFilterer: RollupTimeFilterer{contract: contract}}, nil
}

// NewRollupTimeCaller creates a new read-only instance of RollupTime, bound to a specific deployed contract.
func NewRollupTimeCaller(address common.Address, caller bind.ContractCaller) (*RollupTimeCaller, error) {
	contract, err := bindRollupTime(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RollupTimeCaller{contract: contract}, nil
}

// NewRollupTimeTransactor creates a new write-only instance of RollupTime, bound to a specific deployed contract.
func NewRollupTimeTransactor(address common.Address, transactor bind.ContractTransactor) (*RollupTimeTransactor, error) {
	contract, err := bindRollupTime(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RollupTimeTransactor{contract: contract}, nil
}

// NewRollupTimeFilterer creates a new log filterer instance of RollupTime, bound to a specific deployed contract.
func NewRollupTimeFilterer(address common.Address, filterer bind.ContractFilterer) (*RollupTimeFilterer, error) {
	contract, err := bindRollupTime(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RollupTimeFilterer{contract: contract}, nil
}

// bindRollupTime binds a generic wrapper to an already deployed contract.
func bindRollupTime(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(RollupTimeABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RollupTime *RollupTimeRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RollupTime.Contract.RollupTimeCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RollupTime *RollupTimeRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RollupTime.Contract.RollupTimeTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RollupTime *RollupTimeRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RollupTime.Contract.RollupTimeTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RollupTime *RollupTimeCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RollupTime.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RollupTime *RollupTimeTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RollupTime.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RollupTime *RollupTimeTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RollupTime.Contract.contract.Transact(opts, method, params...)
}

// RollupUtilsABI is the input ABI used to generate the binding from.
const RollupUtilsABI = "[]"

// RollupUtilsBin is the compiled bytecode used for deploying new contracts.
var RollupUtilsBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a723158207dd23e56f87a83cfb260eb12ecc74ff8f79e34a5b4f053c600a4282f1331589c64736f6c63430005100032"

// DeployRollupUtils deploys a new Ethereum contract, binding an instance of RollupUtils to it.
func DeployRollupUtils(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *RollupUtils, error) {
	parsed, err := abi.JSON(strings.NewReader(RollupUtilsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(RollupUtilsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &RollupUtils{RollupUtilsCaller: RollupUtilsCaller{contract: contract}, RollupUtilsTransactor: RollupUtilsTransactor{contract: contract}, RollupUtilsFilterer: RollupUtilsFilterer{contract: contract}}, nil
}

// RollupUtils is an auto generated Go binding around an Ethereum contract.
type RollupUtils struct {
	RollupUtilsCaller     // Read-only binding to the contract
	RollupUtilsTransactor // Write-only binding to the contract
	RollupUtilsFilterer   // Log filterer for contract events
}

// RollupUtilsCaller is an auto generated read-only Go binding around an Ethereum contract.
type RollupUtilsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupUtilsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type RollupUtilsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupUtilsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type RollupUtilsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// RollupUtilsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type RollupUtilsSession struct {
	Contract     *RollupUtils      // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// RollupUtilsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type RollupUtilsCallerSession struct {
	Contract *RollupUtilsCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts      // Call options to use throughout this session
}

// RollupUtilsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type RollupUtilsTransactorSession struct {
	Contract     *RollupUtilsTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts      // Transaction auth options to use throughout this session
}

// RollupUtilsRaw is an auto generated low-level Go binding around an Ethereum contract.
type RollupUtilsRaw struct {
	Contract *RollupUtils // Generic contract binding to access the raw methods on
}

// RollupUtilsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type RollupUtilsCallerRaw struct {
	Contract *RollupUtilsCaller // Generic read-only contract binding to access the raw methods on
}

// RollupUtilsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type RollupUtilsTransactorRaw struct {
	Contract *RollupUtilsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewRollupUtils creates a new instance of RollupUtils, bound to a specific deployed contract.
func NewRollupUtils(address common.Address, backend bind.ContractBackend) (*RollupUtils, error) {
	contract, err := bindRollupUtils(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &RollupUtils{RollupUtilsCaller: RollupUtilsCaller{contract: contract}, RollupUtilsTransactor: RollupUtilsTransactor{contract: contract}, RollupUtilsFilterer: RollupUtilsFilterer{contract: contract}}, nil
}

// NewRollupUtilsCaller creates a new read-only instance of RollupUtils, bound to a specific deployed contract.
func NewRollupUtilsCaller(address common.Address, caller bind.ContractCaller) (*RollupUtilsCaller, error) {
	contract, err := bindRollupUtils(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &RollupUtilsCaller{contract: contract}, nil
}

// NewRollupUtilsTransactor creates a new write-only instance of RollupUtils, bound to a specific deployed contract.
func NewRollupUtilsTransactor(address common.Address, transactor bind.ContractTransactor) (*RollupUtilsTransactor, error) {
	contract, err := bindRollupUtils(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &RollupUtilsTransactor{contract: contract}, nil
}

// NewRollupUtilsFilterer creates a new log filterer instance of RollupUtils, bound to a specific deployed contract.
func NewRollupUtilsFilterer(address common.Address, filterer bind.ContractFilterer) (*RollupUtilsFilterer, error) {
	contract, err := bindRollupUtils(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &RollupUtilsFilterer{contract: contract}, nil
}

// bindRollupUtils binds a generic wrapper to an already deployed contract.
func bindRollupUtils(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(RollupUtilsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RollupUtils *RollupUtilsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RollupUtils.Contract.RollupUtilsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RollupUtils *RollupUtilsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RollupUtils.Contract.RollupUtilsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RollupUtils *RollupUtilsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RollupUtils.Contract.RollupUtilsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_RollupUtils *RollupUtilsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _RollupUtils.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_RollupUtils *RollupUtilsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _RollupUtils.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_RollupUtils *RollupUtilsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _RollupUtils.Contract.contract.Transact(opts, method, params...)
}

// SafeMathABI is the input ABI used to generate the binding from.
const SafeMathABI = "[]"

// SafeMathBin is the compiled bytecode used for deploying new contracts.
var SafeMathBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820ad10c66bf996910d9e61de5011ee8f5129e1674442438cbe46ad0b2dbf02a2d064736f6c63430005100032"

// DeploySafeMath deploys a new Ethereum contract, binding an instance of SafeMath to it.
func DeploySafeMath(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *SafeMath, error) {
	parsed, err := abi.JSON(strings.NewReader(SafeMathABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(SafeMathBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &SafeMath{SafeMathCaller: SafeMathCaller{contract: contract}, SafeMathTransactor: SafeMathTransactor{contract: contract}, SafeMathFilterer: SafeMathFilterer{contract: contract}}, nil
}

// SafeMath is an auto generated Go binding around an Ethereum contract.
type SafeMath struct {
	SafeMathCaller     // Read-only binding to the contract
	SafeMathTransactor // Write-only binding to the contract
	SafeMathFilterer   // Log filterer for contract events
}

// SafeMathCaller is an auto generated read-only Go binding around an Ethereum contract.
type SafeMathCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SafeMathTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SafeMathFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SafeMathSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SafeMathSession struct {
	Contract     *SafeMath         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SafeMathCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SafeMathCallerSession struct {
	Contract *SafeMathCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// SafeMathTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SafeMathTransactorSession struct {
	Contract     *SafeMathTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// SafeMathRaw is an auto generated low-level Go binding around an Ethereum contract.
type SafeMathRaw struct {
	Contract *SafeMath // Generic contract binding to access the raw methods on
}

// SafeMathCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SafeMathCallerRaw struct {
	Contract *SafeMathCaller // Generic read-only contract binding to access the raw methods on
}

// SafeMathTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SafeMathTransactorRaw struct {
	Contract *SafeMathTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSafeMath creates a new instance of SafeMath, bound to a specific deployed contract.
func NewSafeMath(address common.Address, backend bind.ContractBackend) (*SafeMath, error) {
	contract, err := bindSafeMath(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &SafeMath{SafeMathCaller: SafeMathCaller{contract: contract}, SafeMathTransactor: SafeMathTransactor{contract: contract}, SafeMathFilterer: SafeMathFilterer{contract: contract}}, nil
}

// NewSafeMathCaller creates a new read-only instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathCaller(address common.Address, caller bind.ContractCaller) (*SafeMathCaller, error) {
	contract, err := bindSafeMath(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SafeMathCaller{contract: contract}, nil
}

// NewSafeMathTransactor creates a new write-only instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathTransactor(address common.Address, transactor bind.ContractTransactor) (*SafeMathTransactor, error) {
	contract, err := bindSafeMath(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SafeMathTransactor{contract: contract}, nil
}

// NewSafeMathFilterer creates a new log filterer instance of SafeMath, bound to a specific deployed contract.
func NewSafeMathFilterer(address common.Address, filterer bind.ContractFilterer) (*SafeMathFilterer, error) {
	contract, err := bindSafeMath(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SafeMathFilterer{contract: contract}, nil
}

// bindSafeMath binds a generic wrapper to an already deployed contract.
func bindSafeMath(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(SafeMathABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeMath *SafeMathRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SafeMath.Contract.SafeMathCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeMath *SafeMathRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeMath.Contract.SafeMathTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeMath *SafeMathRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeMath.Contract.SafeMathTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_SafeMath *SafeMathCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _SafeMath.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_SafeMath *SafeMathTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _SafeMath.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_SafeMath *SafeMathTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _SafeMath.Contract.contract.Transact(opts, method, params...)
}

// SnapshotABI is the input ABI used to generate the binding from.
const SnapshotABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"stakerLocations\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedDeadlineStakersSnapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"latestConfirmed\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedLatestConfirmedSnapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedNodeExistsSnapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"location1\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"location2\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedTwoStakersSnapshot\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getMySnapshot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]"

// SnapshotFuncSigs maps the 4-byte function signature to its string representation.
var SnapshotFuncSigs = map[string]string{
	"c3f8ae34": "getMySnapshot(uint256)",
}

// SnapshotBin is the compiled bytecode used for deploying new contracts.
var SnapshotBin = "0x6080604052348015600f57600080fd5b5060a98061001e6000396000f3fe6080604052348015600f57600080fd5b506004361060285760003560e01c8063c3f8ae3414602d575b600080fd5b604760048036036020811015604157600080fd5b50356059565b60408051918252519081900360200190f35b3360009081526020818152604080832093835292905220549056fea265627a7a72315820300cf0819e98687758ab3df6adb275d761382de6f1d4dd018a518d63261de21a64736f6c63430005100032"

// DeploySnapshot deploys a new Ethereum contract, binding an instance of Snapshot to it.
func DeploySnapshot(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Snapshot, error) {
	parsed, err := abi.JSON(strings.NewReader(SnapshotABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(SnapshotBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Snapshot{SnapshotCaller: SnapshotCaller{contract: contract}, SnapshotTransactor: SnapshotTransactor{contract: contract}, SnapshotFilterer: SnapshotFilterer{contract: contract}}, nil
}

// Snapshot is an auto generated Go binding around an Ethereum contract.
type Snapshot struct {
	SnapshotCaller     // Read-only binding to the contract
	SnapshotTransactor // Write-only binding to the contract
	SnapshotFilterer   // Log filterer for contract events
}

// SnapshotCaller is an auto generated read-only Go binding around an Ethereum contract.
type SnapshotCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SnapshotTransactor is an auto generated write-only Go binding around an Ethereum contract.
type SnapshotTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SnapshotFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type SnapshotFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// SnapshotSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type SnapshotSession struct {
	Contract     *Snapshot         // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// SnapshotCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type SnapshotCallerSession struct {
	Contract *SnapshotCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts   // Call options to use throughout this session
}

// SnapshotTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type SnapshotTransactorSession struct {
	Contract     *SnapshotTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts   // Transaction auth options to use throughout this session
}

// SnapshotRaw is an auto generated low-level Go binding around an Ethereum contract.
type SnapshotRaw struct {
	Contract *Snapshot // Generic contract binding to access the raw methods on
}

// SnapshotCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type SnapshotCallerRaw struct {
	Contract *SnapshotCaller // Generic read-only contract binding to access the raw methods on
}

// SnapshotTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type SnapshotTransactorRaw struct {
	Contract *SnapshotTransactor // Generic write-only contract binding to access the raw methods on
}

// NewSnapshot creates a new instance of Snapshot, bound to a specific deployed contract.
func NewSnapshot(address common.Address, backend bind.ContractBackend) (*Snapshot, error) {
	contract, err := bindSnapshot(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Snapshot{SnapshotCaller: SnapshotCaller{contract: contract}, SnapshotTransactor: SnapshotTransactor{contract: contract}, SnapshotFilterer: SnapshotFilterer{contract: contract}}, nil
}

// NewSnapshotCaller creates a new read-only instance of Snapshot, bound to a specific deployed contract.
func NewSnapshotCaller(address common.Address, caller bind.ContractCaller) (*SnapshotCaller, error) {
	contract, err := bindSnapshot(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &SnapshotCaller{contract: contract}, nil
}

// NewSnapshotTransactor creates a new write-only instance of Snapshot, bound to a specific deployed contract.
func NewSnapshotTransactor(address common.Address, transactor bind.ContractTransactor) (*SnapshotTransactor, error) {
	contract, err := bindSnapshot(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &SnapshotTransactor{contract: contract}, nil
}

// NewSnapshotFilterer creates a new log filterer instance of Snapshot, bound to a specific deployed contract.
func NewSnapshotFilterer(address common.Address, filterer bind.ContractFilterer) (*SnapshotFilterer, error) {
	contract, err := bindSnapshot(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &SnapshotFilterer{contract: contract}, nil
}

// bindSnapshot binds a generic wrapper to an already deployed contract.
func bindSnapshot(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(SnapshotABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Snapshot *SnapshotRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Snapshot.Contract.SnapshotCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Snapshot *SnapshotRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Snapshot.Contract.SnapshotTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Snapshot *SnapshotRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Snapshot.Contract.SnapshotTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Snapshot *SnapshotCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Snapshot.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Snapshot *SnapshotTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Snapshot.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Snapshot *SnapshotTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Snapshot.Contract.contract.Transact(opts, method, params...)
}

// GetMySnapshot is a free data retrieval call binding the contract method 0xc3f8ae34.
//
// Solidity: function getMySnapshot(uint256 idx) constant returns(bytes32)
func (_Snapshot *SnapshotCaller) GetMySnapshot(opts *bind.CallOpts, idx *big.Int) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _Snapshot.contract.Call(opts, out, "getMySnapshot", idx)
	return *ret0, err
}

// GetMySnapshot is a free data retrieval call binding the contract method 0xc3f8ae34.
//
// Solidity: function getMySnapshot(uint256 idx) constant returns(bytes32)
func (_Snapshot *SnapshotSession) GetMySnapshot(idx *big.Int) ([32]byte, error) {
	return _Snapshot.Contract.GetMySnapshot(&_Snapshot.CallOpts, idx)
}

// GetMySnapshot is a free data retrieval call binding the contract method 0xc3f8ae34.
//
// Solidity: function getMySnapshot(uint256 idx) constant returns(bytes32)
func (_Snapshot *SnapshotCallerSession) GetMySnapshot(idx *big.Int) ([32]byte, error) {
	return _Snapshot.Contract.GetMySnapshot(&_Snapshot.CallOpts, idx)
}

// SnapshotSavedDeadlineStakersSnapshotIterator is returned from FilterSavedDeadlineStakersSnapshot and is used to iterate over the raw logs and unpacked data for SavedDeadlineStakersSnapshot events raised by the Snapshot contract.
type SnapshotSavedDeadlineStakersSnapshotIterator struct {
	Event *SnapshotSavedDeadlineStakersSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotSavedDeadlineStakersSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotSavedDeadlineStakersSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotSavedDeadlineStakersSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotSavedDeadlineStakersSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotSavedDeadlineStakersSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotSavedDeadlineStakersSnapshot represents a SavedDeadlineStakersSnapshot event raised by the Snapshot contract.
type SnapshotSavedDeadlineStakersSnapshot struct {
	Client          common.Address
	DeadlineTicks   *big.Int
	StakerLocations [][32]byte
	Snapshot        [32]byte
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterSavedDeadlineStakersSnapshot is a free log retrieval operation binding the contract event 0x74ea644e404c0a911c3b4cceddbacb969cff8a6efc7efae69d1d9be45e6f1983.
//
// Solidity: event SavedDeadlineStakersSnapshot(address client, uint256 deadlineTicks, bytes32[] stakerLocations, bytes32 snapshot)
func (_Snapshot *SnapshotFilterer) FilterSavedDeadlineStakersSnapshot(opts *bind.FilterOpts) (*SnapshotSavedDeadlineStakersSnapshotIterator, error) {

	logs, sub, err := _Snapshot.contract.FilterLogs(opts, "SavedDeadlineStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return &SnapshotSavedDeadlineStakersSnapshotIterator{contract: _Snapshot.contract, event: "SavedDeadlineStakersSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedDeadlineStakersSnapshot is a free log subscription operation binding the contract event 0x74ea644e404c0a911c3b4cceddbacb969cff8a6efc7efae69d1d9be45e6f1983.
//
// Solidity: event SavedDeadlineStakersSnapshot(address client, uint256 deadlineTicks, bytes32[] stakerLocations, bytes32 snapshot)
func (_Snapshot *SnapshotFilterer) WatchSavedDeadlineStakersSnapshot(opts *bind.WatchOpts, sink chan<- *SnapshotSavedDeadlineStakersSnapshot) (event.Subscription, error) {

	logs, sub, err := _Snapshot.contract.WatchLogs(opts, "SavedDeadlineStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotSavedDeadlineStakersSnapshot)
				if err := _Snapshot.contract.UnpackLog(event, "SavedDeadlineStakersSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedDeadlineStakersSnapshot is a log parse operation binding the contract event 0x74ea644e404c0a911c3b4cceddbacb969cff8a6efc7efae69d1d9be45e6f1983.
//
// Solidity: event SavedDeadlineStakersSnapshot(address client, uint256 deadlineTicks, bytes32[] stakerLocations, bytes32 snapshot)
func (_Snapshot *SnapshotFilterer) ParseSavedDeadlineStakersSnapshot(log types.Log) (*SnapshotSavedDeadlineStakersSnapshot, error) {
	event := new(SnapshotSavedDeadlineStakersSnapshot)
	if err := _Snapshot.contract.UnpackLog(event, "SavedDeadlineStakersSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotSavedLatestConfirmedSnapshotIterator is returned from FilterSavedLatestConfirmedSnapshot and is used to iterate over the raw logs and unpacked data for SavedLatestConfirmedSnapshot events raised by the Snapshot contract.
type SnapshotSavedLatestConfirmedSnapshotIterator struct {
	Event *SnapshotSavedLatestConfirmedSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotSavedLatestConfirmedSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotSavedLatestConfirmedSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotSavedLatestConfirmedSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotSavedLatestConfirmedSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotSavedLatestConfirmedSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotSavedLatestConfirmedSnapshot represents a SavedLatestConfirmedSnapshot event raised by the Snapshot contract.
type SnapshotSavedLatestConfirmedSnapshot struct {
	Client          common.Address
	LatestConfirmed [32]byte
	Snapshot        [32]byte
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterSavedLatestConfirmedSnapshot is a free log retrieval operation binding the contract event 0x01e422abe4c07a9d56a7f67171e2f76848c67d632c74dcd3a5cbb50c63c22ca2.
//
// Solidity: event SavedLatestConfirmedSnapshot(address client, bytes32 latestConfirmed, bytes32 snapshot)
func (_Snapshot *SnapshotFilterer) FilterSavedLatestConfirmedSnapshot(opts *bind.FilterOpts) (*SnapshotSavedLatestConfirmedSnapshotIterator, error) {

	logs, sub, err := _Snapshot.contract.FilterLogs(opts, "SavedLatestConfirmedSnapshot")
	if err != nil {
		return nil, err
	}
	return &SnapshotSavedLatestConfirmedSnapshotIterator{contract: _Snapshot.contract, event: "SavedLatestConfirmedSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedLatestConfirmedSnapshot is a free log subscription operation binding the contract event 0x01e422abe4c07a9d56a7f67171e2f76848c67d632c74dcd3a5cbb50c63c22ca2.
//
// Solidity: event SavedLatestConfirmedSnapshot(address client, bytes32 latestConfirmed, bytes32 snapshot)
func (_Snapshot *SnapshotFilterer) WatchSavedLatestConfirmedSnapshot(opts *bind.WatchOpts, sink chan<- *SnapshotSavedLatestConfirmedSnapshot) (event.Subscription, error) {

	logs, sub, err := _Snapshot.contract.WatchLogs(opts, "SavedLatestConfirmedSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotSavedLatestConfirmedSnapshot)
				if err := _Snapshot.contract.UnpackLog(event, "SavedLatestConfirmedSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedLatestConfirmedSnapshot is a log parse operation binding the contract event 0x01e422abe4c07a9d56a7f67171e2f76848c67d632c74dcd3a5cbb50c63c22ca2.
//
// Solidity: event SavedLatestConfirmedSnapshot(address client, bytes32 latestConfirmed, bytes32 snapshot)
func (_Snapshot *SnapshotFilterer) ParseSavedLatestConfirmedSnapshot(log types.Log) (*SnapshotSavedLatestConfirmedSnapshot, error) {
	event := new(SnapshotSavedLatestConfirmedSnapshot)
	if err := _Snapshot.contract.UnpackLog(event, "SavedLatestConfirmedSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotSavedNodeExistsSnapshotIterator is returned from FilterSavedNodeExistsSnapshot and is used to iterate over the raw logs and unpacked data for SavedNodeExistsSnapshot events raised by the Snapshot contract.
type SnapshotSavedNodeExistsSnapshotIterator struct {
	Event *SnapshotSavedNodeExistsSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotSavedNodeExistsSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotSavedNodeExistsSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotSavedNodeExistsSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotSavedNodeExistsSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotSavedNodeExistsSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotSavedNodeExistsSnapshot represents a SavedNodeExistsSnapshot event raised by the Snapshot contract.
type SnapshotSavedNodeExistsSnapshot struct {
	Client   common.Address
	NodeHash [32]byte
	Snapshot [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterSavedNodeExistsSnapshot is a free log retrieval operation binding the contract event 0x98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556.
//
// Solidity: event SavedNodeExistsSnapshot(address client, bytes32 nodeHash, bytes32 snapshot)
func (_Snapshot *SnapshotFilterer) FilterSavedNodeExistsSnapshot(opts *bind.FilterOpts) (*SnapshotSavedNodeExistsSnapshotIterator, error) {

	logs, sub, err := _Snapshot.contract.FilterLogs(opts, "SavedNodeExistsSnapshot")
	if err != nil {
		return nil, err
	}
	return &SnapshotSavedNodeExistsSnapshotIterator{contract: _Snapshot.contract, event: "SavedNodeExistsSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedNodeExistsSnapshot is a free log subscription operation binding the contract event 0x98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556.
//
// Solidity: event SavedNodeExistsSnapshot(address client, bytes32 nodeHash, bytes32 snapshot)
func (_Snapshot *SnapshotFilterer) WatchSavedNodeExistsSnapshot(opts *bind.WatchOpts, sink chan<- *SnapshotSavedNodeExistsSnapshot) (event.Subscription, error) {

	logs, sub, err := _Snapshot.contract.WatchLogs(opts, "SavedNodeExistsSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotSavedNodeExistsSnapshot)
				if err := _Snapshot.contract.UnpackLog(event, "SavedNodeExistsSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedNodeExistsSnapshot is a log parse operation binding the contract event 0x98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556.
//
// Solidity: event SavedNodeExistsSnapshot(address client, bytes32 nodeHash, bytes32 snapshot)
func (_Snapshot *SnapshotFilterer) ParseSavedNodeExistsSnapshot(log types.Log) (*SnapshotSavedNodeExistsSnapshot, error) {
	event := new(SnapshotSavedNodeExistsSnapshot)
	if err := _Snapshot.contract.UnpackLog(event, "SavedNodeExistsSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// SnapshotSavedTwoStakersSnapshotIterator is returned from FilterSavedTwoStakersSnapshot and is used to iterate over the raw logs and unpacked data for SavedTwoStakersSnapshot events raised by the Snapshot contract.
type SnapshotSavedTwoStakersSnapshotIterator struct {
	Event *SnapshotSavedTwoStakersSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *SnapshotSavedTwoStakersSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(SnapshotSavedTwoStakersSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(SnapshotSavedTwoStakersSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *SnapshotSavedTwoStakersSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *SnapshotSavedTwoStakersSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// SnapshotSavedTwoStakersSnapshot represents a SavedTwoStakersSnapshot event raised by the Snapshot contract.
type SnapshotSavedTwoStakersSnapshot struct {
	Client    common.Address
	Addr1     common.Address
	Location1 [32]byte
	Addr2     common.Address
	Location2 [32]byte
	Snapshot  [32]byte
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterSavedTwoStakersSnapshot is a free log retrieval operation binding the contract event 0x18410fe1e6e0f23683d25f04192e6b95d64681eee6fc2abe5241d2f58cbfbe52.
//
// Solidity: event SavedTwoStakersSnapshot(address client, address addr1, bytes32 location1, address addr2, bytes32 location2, bytes32 snapshot)
func (_Snapshot *SnapshotFilterer) FilterSavedTwoStakersSnapshot(opts *bind.FilterOpts) (*SnapshotSavedTwoStakersSnapshotIterator, error) {

	logs, sub, err := _Snapshot.contract.FilterLogs(opts, "SavedTwoStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return &SnapshotSavedTwoStakersSnapshotIterator{contract: _Snapshot.contract, event: "SavedTwoStakersSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedTwoStakersSnapshot is a free log subscription operation binding the contract event 0x18410fe1e6e0f23683d25f04192e6b95d64681eee6fc2abe5241d2f58cbfbe52.
//
// Solidity: event SavedTwoStakersSnapshot(address client, address addr1, bytes32 location1, address addr2, bytes32 location2, bytes32 snapshot)
func (_Snapshot *SnapshotFilterer) WatchSavedTwoStakersSnapshot(opts *bind.WatchOpts, sink chan<- *SnapshotSavedTwoStakersSnapshot) (event.Subscription, error) {

	logs, sub, err := _Snapshot.contract.WatchLogs(opts, "SavedTwoStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(SnapshotSavedTwoStakersSnapshot)
				if err := _Snapshot.contract.UnpackLog(event, "SavedTwoStakersSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedTwoStakersSnapshot is a log parse operation binding the contract event 0x18410fe1e6e0f23683d25f04192e6b95d64681eee6fc2abe5241d2f58cbfbe52.
//
// Solidity: event SavedTwoStakersSnapshot(address client, address addr1, bytes32 location1, address addr2, bytes32 location2, bytes32 snapshot)
func (_Snapshot *SnapshotFilterer) ParseSavedTwoStakersSnapshot(log types.Log) (*SnapshotSavedTwoStakersSnapshot, error) {
	event := new(SnapshotSavedTwoStakersSnapshot)
	if err := _Snapshot.contract.UnpackLog(event, "SavedTwoStakersSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingABI is the input ABI used to generate the binding from.
const StakingABI = "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengeContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"}],\"name\":\"RollupChallengeCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asserter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"challengeType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challengeContract\",\"type\":\"address\"}],\"name\":\"RollupChallengeStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupStakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"toNodeHash\",\"type\":\"bytes32\"}],\"name\":\"RollupStakeMoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"RollupStakeRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"stakerLocations\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedDeadlineStakersSnapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"latestConfirmed\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedLatestConfirmedSnapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedNodeExistsSnapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"location1\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr2\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"location2\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"snapshot\",\"type\":\"bytes32\"}],\"name\":\"SavedTwoStakersSnapshot\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeFactory\",\"outputs\":[{\"internalType\":\"contractIChallengeFactory\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getMySnapshot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStakeRequired\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stakerAddress\",\"type\":\"address\"}],\"name\":\"isStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"winner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"resolveChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"beforeDeadlineAddrs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"atOrAfterDeadlineAddrs\",\"type\":\"address[]\"}],\"name\":\"snapshotDeadlineStakers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"snapshotStakerNodeExists\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr2\",\"type\":\"address\"}],\"name\":\"snapshotTwoStakers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"addresspayable\",\"name\":\"asserterAddress\",\"type\":\"address\"},{\"internalType\":\"addresspayable\",\"name\":\"challengerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"prevNode\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadlineTicks\",\"type\":\"uint256\"},{\"internalType\":\"uint256[2]\",\"name\":\"stakerNodeTypes\",\"type\":\"uint256[2]\"},{\"internalType\":\"bytes32[2]\",\"name\":\"vmProtoHashes\",\"type\":\"bytes32[2]\"},{\"internalType\":\"bytes32[]\",\"name\":\"asserterProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"challengerProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"asserterNodeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"challengerDataHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"challengerPeriodTicks\",\"type\":\"uint128\"}],\"name\":\"startChallenge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// StakingFuncSigs maps the 4-byte function signature to its string representation.
var StakingFuncSigs = map[string]string{
	"5dbaf68b": "challengeFactory()",
	"c3f8ae34": "getMySnapshot(uint256)",
	"d16c305d": "getStakeRequired()",
	"6177fd18": "isStaked(address)",
	"6bc3cd22": "resolveChallenge(address,address,uint256)",
	"35fa6a6a": "snapshotDeadlineStakers(uint256,uint256,address[],address[])",
	"b7c83f3d": "snapshotStakerNodeExists(uint256,address)",
	"3cdb5dbe": "snapshotTwoStakers(uint256,address,address)",
	"bac5963f": "startChallenge(address,address,bytes32,uint256,uint256[2],bytes32[2],bytes32[],bytes32[],bytes32,bytes32,uint128)",
}

// StakingBin is the compiled bytecode used for deploying new contracts.
var StakingBin = "0x608060405234801561001057600080fd5b506114ad806100206000396000f3fe608060405234801561001057600080fd5b50600436106100935760003560e01c80636bc3cd22116100665780636bc3cd221461025b578063b7c83f3d14610291578063bac5963f146102bd578063c3f8ae341461046f578063d16c305d1461049e57610093565b806335fa6a6a146100985780633cdb5dbe146101c95780635dbaf68b146101fd5780636177fd1814610221575b600080fd5b6101c7600480360360808110156100ae57600080fd5b813591602081013591810190606081016040820135600160201b8111156100d457600080fd5b8201836020820111156100e657600080fd5b803590602001918460208302840111600160201b8311171561010757600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b81111561015657600080fd5b82018360208201111561016857600080fd5b803590602001918460208302840111600160201b8311171561018957600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295506104c2945050505050565b005b6101c7600480360360608110156101df57600080fd5b508035906001600160a01b03602082013581169160400135166107bb565b6102056107f1565b604080516001600160a01b039092168252519081900360200190f35b6102476004803603602081101561023757600080fd5b50356001600160a01b0316610800565b604080519115158252519081900360200190f35b6101c76004803603606081101561027157600080fd5b506001600160a01b0381358116916020810135909116906040013561081d565b6101c7600480360360408110156102a757600080fd5b50803590602001356001600160a01b0316610979565b6101c760048036036101a08110156102d457600080fd5b6040805180820182526001600160a01b0384358116946020810135909116938382013593606083013593918301929160c083019160808401906002908390839080828437600092019190915250506040805180820182529295949381810193925090600290839083908082843760009201919091525091949392602081019250359050600160201b81111561036857600080fd5b82018360208201111561037a57600080fd5b803590602001918460208302840111600160201b8311171561039b57600080fd5b9190808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152509295949360208101935035915050600160201b8111156103ea57600080fd5b8201836020820111156103fc57600080fd5b803590602001918460208302840111600160201b8311171561041d57600080fd5b91908080602002602001604051908101604052809392919081815260200183836020028082843760009201919091525092955050823593505050602081013590604001356001600160801b0316610999565b61048c6004803603602081101561048557600080fd5b5035610f3f565b60408051918252519081900360200190f35b6104a6610f5a565b604080516001600160801b039092168252519081900360200190f35b8151815160045460408051808201909152600a81526910d210d2d7d0d3d5539560b21b602082015290828401146105775760405162461bcd60e51b81526004018080602001828103825283818151815260200191508051906020019080838360005b8381101561053c578181015183820152602001610524565b50505050905090810190601f1680156105695780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b506060826040519080825280602002602001820160405280156105a4578160200160208202803883390190505b5090506000805b848110156106b25760008782815181106105c157fe5b60200260200101519050826001600160601b0319168160601b6001600160601b031916116040518060400160405280600a81526020016921a421a5afa7a92222a960b11b815250906106545760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561053c578181015183820152602001610524565b508060601b9250600061066682610f69565b60018101549091508a90610682906001600160801b0316610ffa565b1061068c57600080fd5b806000015485848151811061069d57fe5b602090810291909101015250506001016105ab565b5060009050805b838110156107a55760008682815181106106cf57fe5b60200260200101519050826001600160601b0319168160601b6001600160601b031916116040518060400160405280600a81526020016921a421a5afa7a92222a960b11b815250906107625760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561053c578181015183820152602001610524565b508060601b9250600061077482610f69565b60018101549091508a90610790906001600160801b0316610ffa565b101561079b57600080fd5b50506001016106b9565b506107b1888884611001565b5050505050505050565b60006107c683610f69565b905060006107d383610f69565b90506107ea858584600001548685600001546110c2565b5050505050565b6001546001600160a01b031681565b6001600160a01b0316600090815260036020526040902054151590565b33600090815260056020908152604091829020548251808401909352600f83526e2922a9afa1a420a62fa9a2a72222a960891b9183019190915260ff166108a55760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561053c578181015183820152602001610524565b50336000908152600560205260408120805460ff191690556108c684610f69565b600280546040519293506001600160a01b038716926001600160801b03918216929092041680156108fc02916000818181858888f19350505050158015610911573d6000803e3d6000fd5b5060018101805460ff60801b1916905561092a83611155565b604080513381526001600160a01b03808716602083015285168183015290517f468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f299181900360600190a150505050565b600061098482610f69565b9050610994838260000154611196565b505050565b60006109a48c610f69565b905060006109b18c610f69565b60018301549091508a906109cd906001600160801b0316610ffa565b106040518060400160405280600d81526020016c53544b315f444541444c494e4560981b81525090610a405760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561053c578181015183820152602001610524565b5060018101548a90610a5a906001600160801b0316610ffa565b106040518060400160405280600d81526020016c53544b325f444541444c494e4560981b81525090610acd5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561053c578181015183820152602001610524565b50600182015460408051808201909152600c81526b14d512cc57d25397d0d2105360a21b602082015290600160801b900460ff1615610b4d5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561053c578181015183820152602001610524565b50600181015460408051808201909152600c81526b14d512cc57d25397d0d2105360a21b602082015290600160801b900460ff1615610bcd5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561053c578181015183820152602001610524565b506020808a01518a5160408051808201909152600a8152692a2ca822afa7a92222a960b11b9381019390935211610c455760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561053c578181015183820152602001610524565b508154610c6d610c678d8d898e600060200201518e60005b6020020151611201565b89611269565b146040518060400160405280600c81526020016b20a9a9a2a92a2fa82927a7a360a11b81525090610cdf5760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561053c578181015183820152602001610524565b508054610d10610d0a8d8d610cfd896001600160801b038a16611280565b60208f01518e6001610c5d565b88611269565b146040518060400160405280600a81526020016921a420a62fa82927a7a360b11b81525090610d805760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561053c578181015183820152602001610524565b5060018260010160106101000a81548160ff02191690831515021790555060018160010160106101000a81548160ff0219169083151502179055506000600160009054906101000a90046001600160a01b03166001600160a01b031663865da1c28f8f87898f600160028110610df257fe5b60200201516040518663ffffffff1660e01b815260040180866001600160a01b03166001600160a01b03168152602001856001600160a01b03166001600160a01b03168152602001846001600160801b0316815260200183815260200182815260200195505050505050602060405180830381600087803b158015610e7657600080fd5b505af1158015610e8a573d6000803e3d6000fd5b505050506040513d6020811015610ea057600080fd5b50516001600160a01b0381166000908152600560205260409020805460ff191660019081179091559091507f6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f908f908f908d9060209081029190910151604080516001600160a01b0395861681529385169284019290925282820152918416606082015290519081900360800190a15050505050505050505050505050565b33600090815260208181526040808320938352929052205490565b6002546001600160801b031690565b6001600160a01b038116600090815260036020908152604080832080548251808401909352600a83526924a72b2fa9aa20a5a2a960b11b9383019390935291610ff35760405162461bcd60e51b815260206004820181815283516024840152835190928392604490910191908501908083836000831561053c578181015183820152602001610524565b5092915050565b6132c80290565b600061100d83836112ac565b336000818152602081815260408083208984528252808320859055805184815280830189905260608101869052608091810182815288519282019290925287519596507f74ea644e404c0a911c3b4cceddbacb969cff8a6efc7efae69d1d9be45e6f1983958994899489949260a08501928783019291909102908190849084905b838110156110a657818101518382015260200161108e565b505050509050019550505050505060405180910390a150505050565b60006110d08585858561134c565b336000818152602081815260408083208b845282529182902084905581519283526001600160a01b0389811691840191909152828201889052861660608301526080820185905260a08201839052519192507f18410fe1e6e0f23683d25f04192e6b95d64681eee6fc2abe5241d2f58cbfbe52919081900360c00190a1505050505050565b6001600160a01b03166000908152600360205260408120908155600101805470ffffffffffffffffffffffffffffffffff1916905560048054600019019055565b60006111a1826113db565b3360008181526020818152604080832088845282529182902084905581519283528201859052818101839052519192507f98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556919081900360600190a1505050565b6040805160208082018490528183018790526060820186905260808083018690528351808403909101815260a08301845280519082012060c0830189905260e08084019190915283518084039091018152610100909201909252805191012095945050505050565b6000611279838360008551611410565b9392505050565b604080516020808201949094528082019290925280518083038201815260609092019052805191012090565b600080805b835181101561130b578381815181106112c657fe5b602002602001015182604051602001808381526020018281526020019250505060405160208183030381529060405280519060200120915080806001019150506112b1565b5060408051600160f91b6020808301919091526021820196909652604180820193909352815180820390930183526061019052805193019290922092915050565b60006001858585856040516020018086600381111561136757fe5b60ff1660f81b8152600101856001600160a01b03166001600160a01b031660601b8152601401848152602001836001600160a01b03166001600160a01b031660601b815260140182815260200195505050505050604051602081830303815290604052805190602001209050949350505050565b60408051600360f81b602080830191909152602180830194909452825180830390940184526041909101909152815191012090565b600084835b8381101561146e578186828151811061142a57fe5b602002602001015160405160200180838152602001828152602001925050506040516020818303038152906040528051906020012091508080600101915050611415565b509594505050505056fea265627a7a7231582079bb171dcc011bbdb4f6335a6972fa9c151194aa701eaa5436cc4c983f27cdb864736f6c63430005100032"

// DeployStaking deploys a new Ethereum contract, binding an instance of Staking to it.
func DeployStaking(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Staking, error) {
	parsed, err := abi.JSON(strings.NewReader(StakingABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(StakingBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Staking{StakingCaller: StakingCaller{contract: contract}, StakingTransactor: StakingTransactor{contract: contract}, StakingFilterer: StakingFilterer{contract: contract}}, nil
}

// Staking is an auto generated Go binding around an Ethereum contract.
type Staking struct {
	StakingCaller     // Read-only binding to the contract
	StakingTransactor // Write-only binding to the contract
	StakingFilterer   // Log filterer for contract events
}

// StakingCaller is an auto generated read-only Go binding around an Ethereum contract.
type StakingCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingTransactor is an auto generated write-only Go binding around an Ethereum contract.
type StakingTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type StakingFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// StakingSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type StakingSession struct {
	Contract     *Staking          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// StakingCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type StakingCallerSession struct {
	Contract *StakingCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// StakingTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type StakingTransactorSession struct {
	Contract     *StakingTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// StakingRaw is an auto generated low-level Go binding around an Ethereum contract.
type StakingRaw struct {
	Contract *Staking // Generic contract binding to access the raw methods on
}

// StakingCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type StakingCallerRaw struct {
	Contract *StakingCaller // Generic read-only contract binding to access the raw methods on
}

// StakingTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type StakingTransactorRaw struct {
	Contract *StakingTransactor // Generic write-only contract binding to access the raw methods on
}

// NewStaking creates a new instance of Staking, bound to a specific deployed contract.
func NewStaking(address common.Address, backend bind.ContractBackend) (*Staking, error) {
	contract, err := bindStaking(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Staking{StakingCaller: StakingCaller{contract: contract}, StakingTransactor: StakingTransactor{contract: contract}, StakingFilterer: StakingFilterer{contract: contract}}, nil
}

// NewStakingCaller creates a new read-only instance of Staking, bound to a specific deployed contract.
func NewStakingCaller(address common.Address, caller bind.ContractCaller) (*StakingCaller, error) {
	contract, err := bindStaking(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &StakingCaller{contract: contract}, nil
}

// NewStakingTransactor creates a new write-only instance of Staking, bound to a specific deployed contract.
func NewStakingTransactor(address common.Address, transactor bind.ContractTransactor) (*StakingTransactor, error) {
	contract, err := bindStaking(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &StakingTransactor{contract: contract}, nil
}

// NewStakingFilterer creates a new log filterer instance of Staking, bound to a specific deployed contract.
func NewStakingFilterer(address common.Address, filterer bind.ContractFilterer) (*StakingFilterer, error) {
	contract, err := bindStaking(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &StakingFilterer{contract: contract}, nil
}

// bindStaking binds a generic wrapper to an already deployed contract.
func bindStaking(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(StakingABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Staking *StakingRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Staking.Contract.StakingCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Staking *StakingRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.Contract.StakingTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Staking *StakingRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Staking.Contract.StakingTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Staking *StakingCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Staking.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Staking *StakingTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Staking.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Staking *StakingTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Staking.Contract.contract.Transact(opts, method, params...)
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() constant returns(address)
func (_Staking *StakingCaller) ChallengeFactory(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "challengeFactory")
	return *ret0, err
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() constant returns(address)
func (_Staking *StakingSession) ChallengeFactory() (common.Address, error) {
	return _Staking.Contract.ChallengeFactory(&_Staking.CallOpts)
}

// ChallengeFactory is a free data retrieval call binding the contract method 0x5dbaf68b.
//
// Solidity: function challengeFactory() constant returns(address)
func (_Staking *StakingCallerSession) ChallengeFactory() (common.Address, error) {
	return _Staking.Contract.ChallengeFactory(&_Staking.CallOpts)
}

// GetMySnapshot is a free data retrieval call binding the contract method 0xc3f8ae34.
//
// Solidity: function getMySnapshot(uint256 idx) constant returns(bytes32)
func (_Staking *StakingCaller) GetMySnapshot(opts *bind.CallOpts, idx *big.Int) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "getMySnapshot", idx)
	return *ret0, err
}

// GetMySnapshot is a free data retrieval call binding the contract method 0xc3f8ae34.
//
// Solidity: function getMySnapshot(uint256 idx) constant returns(bytes32)
func (_Staking *StakingSession) GetMySnapshot(idx *big.Int) ([32]byte, error) {
	return _Staking.Contract.GetMySnapshot(&_Staking.CallOpts, idx)
}

// GetMySnapshot is a free data retrieval call binding the contract method 0xc3f8ae34.
//
// Solidity: function getMySnapshot(uint256 idx) constant returns(bytes32)
func (_Staking *StakingCallerSession) GetMySnapshot(idx *big.Int) ([32]byte, error) {
	return _Staking.Contract.GetMySnapshot(&_Staking.CallOpts, idx)
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() constant returns(uint128)
func (_Staking *StakingCaller) GetStakeRequired(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "getStakeRequired")
	return *ret0, err
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() constant returns(uint128)
func (_Staking *StakingSession) GetStakeRequired() (*big.Int, error) {
	return _Staking.Contract.GetStakeRequired(&_Staking.CallOpts)
}

// GetStakeRequired is a free data retrieval call binding the contract method 0xd16c305d.
//
// Solidity: function getStakeRequired() constant returns(uint128)
func (_Staking *StakingCallerSession) GetStakeRequired() (*big.Int, error) {
	return _Staking.Contract.GetStakeRequired(&_Staking.CallOpts)
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) constant returns(bool)
func (_Staking *StakingCaller) IsStaked(opts *bind.CallOpts, _stakerAddress common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _Staking.contract.Call(opts, out, "isStaked", _stakerAddress)
	return *ret0, err
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) constant returns(bool)
func (_Staking *StakingSession) IsStaked(_stakerAddress common.Address) (bool, error) {
	return _Staking.Contract.IsStaked(&_Staking.CallOpts, _stakerAddress)
}

// IsStaked is a free data retrieval call binding the contract method 0x6177fd18.
//
// Solidity: function isStaked(address _stakerAddress) constant returns(bool)
func (_Staking *StakingCallerSession) IsStaked(_stakerAddress common.Address) (bool, error) {
	return _Staking.Contract.IsStaked(&_Staking.CallOpts, _stakerAddress)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_Staking *StakingTransactor) ResolveChallenge(opts *bind.TransactOpts, winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "resolveChallenge", winner, loser, arg2)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_Staking *StakingSession) ResolveChallenge(winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.ResolveChallenge(&_Staking.TransactOpts, winner, loser, arg2)
}

// ResolveChallenge is a paid mutator transaction binding the contract method 0x6bc3cd22.
//
// Solidity: function resolveChallenge(address winner, address loser, uint256 ) returns()
func (_Staking *StakingTransactorSession) ResolveChallenge(winner common.Address, loser common.Address, arg2 *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.ResolveChallenge(&_Staking.TransactOpts, winner, loser, arg2)
}

// SnapshotDeadlineStakers is a paid mutator transaction binding the contract method 0x35fa6a6a.
//
// Solidity: function snapshotDeadlineStakers(uint256 idx, uint256 deadlineTicks, address[] beforeDeadlineAddrs, address[] atOrAfterDeadlineAddrs) returns()
func (_Staking *StakingTransactor) SnapshotDeadlineStakers(opts *bind.TransactOpts, idx *big.Int, deadlineTicks *big.Int, beforeDeadlineAddrs []common.Address, atOrAfterDeadlineAddrs []common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "snapshotDeadlineStakers", idx, deadlineTicks, beforeDeadlineAddrs, atOrAfterDeadlineAddrs)
}

// SnapshotDeadlineStakers is a paid mutator transaction binding the contract method 0x35fa6a6a.
//
// Solidity: function snapshotDeadlineStakers(uint256 idx, uint256 deadlineTicks, address[] beforeDeadlineAddrs, address[] atOrAfterDeadlineAddrs) returns()
func (_Staking *StakingSession) SnapshotDeadlineStakers(idx *big.Int, deadlineTicks *big.Int, beforeDeadlineAddrs []common.Address, atOrAfterDeadlineAddrs []common.Address) (*types.Transaction, error) {
	return _Staking.Contract.SnapshotDeadlineStakers(&_Staking.TransactOpts, idx, deadlineTicks, beforeDeadlineAddrs, atOrAfterDeadlineAddrs)
}

// SnapshotDeadlineStakers is a paid mutator transaction binding the contract method 0x35fa6a6a.
//
// Solidity: function snapshotDeadlineStakers(uint256 idx, uint256 deadlineTicks, address[] beforeDeadlineAddrs, address[] atOrAfterDeadlineAddrs) returns()
func (_Staking *StakingTransactorSession) SnapshotDeadlineStakers(idx *big.Int, deadlineTicks *big.Int, beforeDeadlineAddrs []common.Address, atOrAfterDeadlineAddrs []common.Address) (*types.Transaction, error) {
	return _Staking.Contract.SnapshotDeadlineStakers(&_Staking.TransactOpts, idx, deadlineTicks, beforeDeadlineAddrs, atOrAfterDeadlineAddrs)
}

// SnapshotStakerNodeExists is a paid mutator transaction binding the contract method 0xb7c83f3d.
//
// Solidity: function snapshotStakerNodeExists(uint256 idx, address addr) returns()
func (_Staking *StakingTransactor) SnapshotStakerNodeExists(opts *bind.TransactOpts, idx *big.Int, addr common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "snapshotStakerNodeExists", idx, addr)
}

// SnapshotStakerNodeExists is a paid mutator transaction binding the contract method 0xb7c83f3d.
//
// Solidity: function snapshotStakerNodeExists(uint256 idx, address addr) returns()
func (_Staking *StakingSession) SnapshotStakerNodeExists(idx *big.Int, addr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.SnapshotStakerNodeExists(&_Staking.TransactOpts, idx, addr)
}

// SnapshotStakerNodeExists is a paid mutator transaction binding the contract method 0xb7c83f3d.
//
// Solidity: function snapshotStakerNodeExists(uint256 idx, address addr) returns()
func (_Staking *StakingTransactorSession) SnapshotStakerNodeExists(idx *big.Int, addr common.Address) (*types.Transaction, error) {
	return _Staking.Contract.SnapshotStakerNodeExists(&_Staking.TransactOpts, idx, addr)
}

// SnapshotTwoStakers is a paid mutator transaction binding the contract method 0x3cdb5dbe.
//
// Solidity: function snapshotTwoStakers(uint256 idx, address addr1, address addr2) returns()
func (_Staking *StakingTransactor) SnapshotTwoStakers(opts *bind.TransactOpts, idx *big.Int, addr1 common.Address, addr2 common.Address) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "snapshotTwoStakers", idx, addr1, addr2)
}

// SnapshotTwoStakers is a paid mutator transaction binding the contract method 0x3cdb5dbe.
//
// Solidity: function snapshotTwoStakers(uint256 idx, address addr1, address addr2) returns()
func (_Staking *StakingSession) SnapshotTwoStakers(idx *big.Int, addr1 common.Address, addr2 common.Address) (*types.Transaction, error) {
	return _Staking.Contract.SnapshotTwoStakers(&_Staking.TransactOpts, idx, addr1, addr2)
}

// SnapshotTwoStakers is a paid mutator transaction binding the contract method 0x3cdb5dbe.
//
// Solidity: function snapshotTwoStakers(uint256 idx, address addr1, address addr2) returns()
func (_Staking *StakingTransactorSession) SnapshotTwoStakers(idx *big.Int, addr1 common.Address, addr2 common.Address) (*types.Transaction, error) {
	return _Staking.Contract.SnapshotTwoStakers(&_Staking.TransactOpts, idx, addr1, addr2)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_Staking *StakingTransactor) StartChallenge(opts *bind.TransactOpts, asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _Staking.contract.Transact(opts, "startChallenge", asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_Staking *StakingSession) StartChallenge(asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.StartChallenge(&_Staking.TransactOpts, asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StartChallenge is a paid mutator transaction binding the contract method 0xbac5963f.
//
// Solidity: function startChallenge(address asserterAddress, address challengerAddress, bytes32 prevNode, uint256 deadlineTicks, uint256[2] stakerNodeTypes, bytes32[2] vmProtoHashes, bytes32[] asserterProof, bytes32[] challengerProof, bytes32 asserterNodeHash, bytes32 challengerDataHash, uint128 challengerPeriodTicks) returns()
func (_Staking *StakingTransactorSession) StartChallenge(asserterAddress common.Address, challengerAddress common.Address, prevNode [32]byte, deadlineTicks *big.Int, stakerNodeTypes [2]*big.Int, vmProtoHashes [2][32]byte, asserterProof [][32]byte, challengerProof [][32]byte, asserterNodeHash [32]byte, challengerDataHash [32]byte, challengerPeriodTicks *big.Int) (*types.Transaction, error) {
	return _Staking.Contract.StartChallenge(&_Staking.TransactOpts, asserterAddress, challengerAddress, prevNode, deadlineTicks, stakerNodeTypes, vmProtoHashes, asserterProof, challengerProof, asserterNodeHash, challengerDataHash, challengerPeriodTicks)
}

// StakingRollupChallengeCompletedIterator is returned from FilterRollupChallengeCompleted and is used to iterate over the raw logs and unpacked data for RollupChallengeCompleted events raised by the Staking contract.
type StakingRollupChallengeCompletedIterator struct {
	Event *StakingRollupChallengeCompleted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupChallengeCompletedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupChallengeCompleted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupChallengeCompleted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupChallengeCompletedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupChallengeCompletedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupChallengeCompleted represents a RollupChallengeCompleted event raised by the Staking contract.
type StakingRollupChallengeCompleted struct {
	ChallengeContract common.Address
	Winner            common.Address
	Loser             common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRollupChallengeCompleted is a free log retrieval operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_Staking *StakingFilterer) FilterRollupChallengeCompleted(opts *bind.FilterOpts) (*StakingRollupChallengeCompletedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupChallengeCompleted")
	if err != nil {
		return nil, err
	}
	return &StakingRollupChallengeCompletedIterator{contract: _Staking.contract, event: "RollupChallengeCompleted", logs: logs, sub: sub}, nil
}

// WatchRollupChallengeCompleted is a free log subscription operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_Staking *StakingFilterer) WatchRollupChallengeCompleted(opts *bind.WatchOpts, sink chan<- *StakingRollupChallengeCompleted) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupChallengeCompleted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupChallengeCompleted)
				if err := _Staking.contract.UnpackLog(event, "RollupChallengeCompleted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupChallengeCompleted is a log parse operation binding the contract event 0x468aa7d460319b17466ca163bca353a0c62fff0d7d0fa287f634ef305d946f29.
//
// Solidity: event RollupChallengeCompleted(address challengeContract, address winner, address loser)
func (_Staking *StakingFilterer) ParseRollupChallengeCompleted(log types.Log) (*StakingRollupChallengeCompleted, error) {
	event := new(StakingRollupChallengeCompleted)
	if err := _Staking.contract.UnpackLog(event, "RollupChallengeCompleted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingRollupChallengeStartedIterator is returned from FilterRollupChallengeStarted and is used to iterate over the raw logs and unpacked data for RollupChallengeStarted events raised by the Staking contract.
type StakingRollupChallengeStartedIterator struct {
	Event *StakingRollupChallengeStarted // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupChallengeStartedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupChallengeStarted)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupChallengeStarted)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupChallengeStartedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupChallengeStartedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupChallengeStarted represents a RollupChallengeStarted event raised by the Staking contract.
type StakingRollupChallengeStarted struct {
	Asserter          common.Address
	Challenger        common.Address
	ChallengeType     *big.Int
	ChallengeContract common.Address
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterRollupChallengeStarted is a free log retrieval operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_Staking *StakingFilterer) FilterRollupChallengeStarted(opts *bind.FilterOpts) (*StakingRollupChallengeStartedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupChallengeStarted")
	if err != nil {
		return nil, err
	}
	return &StakingRollupChallengeStartedIterator{contract: _Staking.contract, event: "RollupChallengeStarted", logs: logs, sub: sub}, nil
}

// WatchRollupChallengeStarted is a free log subscription operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_Staking *StakingFilterer) WatchRollupChallengeStarted(opts *bind.WatchOpts, sink chan<- *StakingRollupChallengeStarted) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupChallengeStarted")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupChallengeStarted)
				if err := _Staking.contract.UnpackLog(event, "RollupChallengeStarted", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupChallengeStarted is a log parse operation binding the contract event 0x6c69257ddf620994c6fb9e5304db0e5563db3765bee033ddd61b6a1caa7d043f.
//
// Solidity: event RollupChallengeStarted(address asserter, address challenger, uint256 challengeType, address challengeContract)
func (_Staking *StakingFilterer) ParseRollupChallengeStarted(log types.Log) (*StakingRollupChallengeStarted, error) {
	event := new(StakingRollupChallengeStarted)
	if err := _Staking.contract.UnpackLog(event, "RollupChallengeStarted", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingRollupStakeCreatedIterator is returned from FilterRollupStakeCreated and is used to iterate over the raw logs and unpacked data for RollupStakeCreated events raised by the Staking contract.
type StakingRollupStakeCreatedIterator struct {
	Event *StakingRollupStakeCreated // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupStakeCreatedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupStakeCreated)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupStakeCreated)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupStakeCreatedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupStakeCreatedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupStakeCreated represents a RollupStakeCreated event raised by the Staking contract.
type StakingRollupStakeCreated struct {
	Staker   common.Address
	NodeHash [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeCreated is a free log retrieval operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_Staking *StakingFilterer) FilterRollupStakeCreated(opts *bind.FilterOpts) (*StakingRollupStakeCreatedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupStakeCreated")
	if err != nil {
		return nil, err
	}
	return &StakingRollupStakeCreatedIterator{contract: _Staking.contract, event: "RollupStakeCreated", logs: logs, sub: sub}, nil
}

// WatchRollupStakeCreated is a free log subscription operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_Staking *StakingFilterer) WatchRollupStakeCreated(opts *bind.WatchOpts, sink chan<- *StakingRollupStakeCreated) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupStakeCreated")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupStakeCreated)
				if err := _Staking.contract.UnpackLog(event, "RollupStakeCreated", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeCreated is a log parse operation binding the contract event 0xcbafbb223ed21c82af9e2ad20cdfdf55d3263d06f9a65b3f70da613f32d81f88.
//
// Solidity: event RollupStakeCreated(address staker, bytes32 nodeHash)
func (_Staking *StakingFilterer) ParseRollupStakeCreated(log types.Log) (*StakingRollupStakeCreated, error) {
	event := new(StakingRollupStakeCreated)
	if err := _Staking.contract.UnpackLog(event, "RollupStakeCreated", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingRollupStakeMovedIterator is returned from FilterRollupStakeMoved and is used to iterate over the raw logs and unpacked data for RollupStakeMoved events raised by the Staking contract.
type StakingRollupStakeMovedIterator struct {
	Event *StakingRollupStakeMoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupStakeMovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupStakeMoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupStakeMoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupStakeMovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupStakeMovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupStakeMoved represents a RollupStakeMoved event raised by the Staking contract.
type StakingRollupStakeMoved struct {
	Staker     common.Address
	ToNodeHash [32]byte
	Raw        types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeMoved is a free log retrieval operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_Staking *StakingFilterer) FilterRollupStakeMoved(opts *bind.FilterOpts) (*StakingRollupStakeMovedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupStakeMoved")
	if err != nil {
		return nil, err
	}
	return &StakingRollupStakeMovedIterator{contract: _Staking.contract, event: "RollupStakeMoved", logs: logs, sub: sub}, nil
}

// WatchRollupStakeMoved is a free log subscription operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_Staking *StakingFilterer) WatchRollupStakeMoved(opts *bind.WatchOpts, sink chan<- *StakingRollupStakeMoved) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupStakeMoved")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupStakeMoved)
				if err := _Staking.contract.UnpackLog(event, "RollupStakeMoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeMoved is a log parse operation binding the contract event 0xbe690ac5fe353c094bcc6f187eeb841c0ca61b6edf32c142eadad655b7d173f4.
//
// Solidity: event RollupStakeMoved(address staker, bytes32 toNodeHash)
func (_Staking *StakingFilterer) ParseRollupStakeMoved(log types.Log) (*StakingRollupStakeMoved, error) {
	event := new(StakingRollupStakeMoved)
	if err := _Staking.contract.UnpackLog(event, "RollupStakeMoved", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingRollupStakeRefundedIterator is returned from FilterRollupStakeRefunded and is used to iterate over the raw logs and unpacked data for RollupStakeRefunded events raised by the Staking contract.
type StakingRollupStakeRefundedIterator struct {
	Event *StakingRollupStakeRefunded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingRollupStakeRefundedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingRollupStakeRefunded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingRollupStakeRefunded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingRollupStakeRefundedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingRollupStakeRefundedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingRollupStakeRefunded represents a RollupStakeRefunded event raised by the Staking contract.
type StakingRollupStakeRefunded struct {
	Staker common.Address
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterRollupStakeRefunded is a free log retrieval operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_Staking *StakingFilterer) FilterRollupStakeRefunded(opts *bind.FilterOpts) (*StakingRollupStakeRefundedIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "RollupStakeRefunded")
	if err != nil {
		return nil, err
	}
	return &StakingRollupStakeRefundedIterator{contract: _Staking.contract, event: "RollupStakeRefunded", logs: logs, sub: sub}, nil
}

// WatchRollupStakeRefunded is a free log subscription operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_Staking *StakingFilterer) WatchRollupStakeRefunded(opts *bind.WatchOpts, sink chan<- *StakingRollupStakeRefunded) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "RollupStakeRefunded")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingRollupStakeRefunded)
				if err := _Staking.contract.UnpackLog(event, "RollupStakeRefunded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRollupStakeRefunded is a log parse operation binding the contract event 0x953ab9eece73c907353307064109cf873462177a0e358e463fd89f5b206daa6c.
//
// Solidity: event RollupStakeRefunded(address staker)
func (_Staking *StakingFilterer) ParseRollupStakeRefunded(log types.Log) (*StakingRollupStakeRefunded, error) {
	event := new(StakingRollupStakeRefunded)
	if err := _Staking.contract.UnpackLog(event, "RollupStakeRefunded", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingSavedDeadlineStakersSnapshotIterator is returned from FilterSavedDeadlineStakersSnapshot and is used to iterate over the raw logs and unpacked data for SavedDeadlineStakersSnapshot events raised by the Staking contract.
type StakingSavedDeadlineStakersSnapshotIterator struct {
	Event *StakingSavedDeadlineStakersSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingSavedDeadlineStakersSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingSavedDeadlineStakersSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingSavedDeadlineStakersSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingSavedDeadlineStakersSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingSavedDeadlineStakersSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingSavedDeadlineStakersSnapshot represents a SavedDeadlineStakersSnapshot event raised by the Staking contract.
type StakingSavedDeadlineStakersSnapshot struct {
	Client          common.Address
	DeadlineTicks   *big.Int
	StakerLocations [][32]byte
	Snapshot        [32]byte
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterSavedDeadlineStakersSnapshot is a free log retrieval operation binding the contract event 0x74ea644e404c0a911c3b4cceddbacb969cff8a6efc7efae69d1d9be45e6f1983.
//
// Solidity: event SavedDeadlineStakersSnapshot(address client, uint256 deadlineTicks, bytes32[] stakerLocations, bytes32 snapshot)
func (_Staking *StakingFilterer) FilterSavedDeadlineStakersSnapshot(opts *bind.FilterOpts) (*StakingSavedDeadlineStakersSnapshotIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "SavedDeadlineStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return &StakingSavedDeadlineStakersSnapshotIterator{contract: _Staking.contract, event: "SavedDeadlineStakersSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedDeadlineStakersSnapshot is a free log subscription operation binding the contract event 0x74ea644e404c0a911c3b4cceddbacb969cff8a6efc7efae69d1d9be45e6f1983.
//
// Solidity: event SavedDeadlineStakersSnapshot(address client, uint256 deadlineTicks, bytes32[] stakerLocations, bytes32 snapshot)
func (_Staking *StakingFilterer) WatchSavedDeadlineStakersSnapshot(opts *bind.WatchOpts, sink chan<- *StakingSavedDeadlineStakersSnapshot) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "SavedDeadlineStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingSavedDeadlineStakersSnapshot)
				if err := _Staking.contract.UnpackLog(event, "SavedDeadlineStakersSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedDeadlineStakersSnapshot is a log parse operation binding the contract event 0x74ea644e404c0a911c3b4cceddbacb969cff8a6efc7efae69d1d9be45e6f1983.
//
// Solidity: event SavedDeadlineStakersSnapshot(address client, uint256 deadlineTicks, bytes32[] stakerLocations, bytes32 snapshot)
func (_Staking *StakingFilterer) ParseSavedDeadlineStakersSnapshot(log types.Log) (*StakingSavedDeadlineStakersSnapshot, error) {
	event := new(StakingSavedDeadlineStakersSnapshot)
	if err := _Staking.contract.UnpackLog(event, "SavedDeadlineStakersSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingSavedLatestConfirmedSnapshotIterator is returned from FilterSavedLatestConfirmedSnapshot and is used to iterate over the raw logs and unpacked data for SavedLatestConfirmedSnapshot events raised by the Staking contract.
type StakingSavedLatestConfirmedSnapshotIterator struct {
	Event *StakingSavedLatestConfirmedSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingSavedLatestConfirmedSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingSavedLatestConfirmedSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingSavedLatestConfirmedSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingSavedLatestConfirmedSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingSavedLatestConfirmedSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingSavedLatestConfirmedSnapshot represents a SavedLatestConfirmedSnapshot event raised by the Staking contract.
type StakingSavedLatestConfirmedSnapshot struct {
	Client          common.Address
	LatestConfirmed [32]byte
	Snapshot        [32]byte
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterSavedLatestConfirmedSnapshot is a free log retrieval operation binding the contract event 0x01e422abe4c07a9d56a7f67171e2f76848c67d632c74dcd3a5cbb50c63c22ca2.
//
// Solidity: event SavedLatestConfirmedSnapshot(address client, bytes32 latestConfirmed, bytes32 snapshot)
func (_Staking *StakingFilterer) FilterSavedLatestConfirmedSnapshot(opts *bind.FilterOpts) (*StakingSavedLatestConfirmedSnapshotIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "SavedLatestConfirmedSnapshot")
	if err != nil {
		return nil, err
	}
	return &StakingSavedLatestConfirmedSnapshotIterator{contract: _Staking.contract, event: "SavedLatestConfirmedSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedLatestConfirmedSnapshot is a free log subscription operation binding the contract event 0x01e422abe4c07a9d56a7f67171e2f76848c67d632c74dcd3a5cbb50c63c22ca2.
//
// Solidity: event SavedLatestConfirmedSnapshot(address client, bytes32 latestConfirmed, bytes32 snapshot)
func (_Staking *StakingFilterer) WatchSavedLatestConfirmedSnapshot(opts *bind.WatchOpts, sink chan<- *StakingSavedLatestConfirmedSnapshot) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "SavedLatestConfirmedSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingSavedLatestConfirmedSnapshot)
				if err := _Staking.contract.UnpackLog(event, "SavedLatestConfirmedSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedLatestConfirmedSnapshot is a log parse operation binding the contract event 0x01e422abe4c07a9d56a7f67171e2f76848c67d632c74dcd3a5cbb50c63c22ca2.
//
// Solidity: event SavedLatestConfirmedSnapshot(address client, bytes32 latestConfirmed, bytes32 snapshot)
func (_Staking *StakingFilterer) ParseSavedLatestConfirmedSnapshot(log types.Log) (*StakingSavedLatestConfirmedSnapshot, error) {
	event := new(StakingSavedLatestConfirmedSnapshot)
	if err := _Staking.contract.UnpackLog(event, "SavedLatestConfirmedSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingSavedNodeExistsSnapshotIterator is returned from FilterSavedNodeExistsSnapshot and is used to iterate over the raw logs and unpacked data for SavedNodeExistsSnapshot events raised by the Staking contract.
type StakingSavedNodeExistsSnapshotIterator struct {
	Event *StakingSavedNodeExistsSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingSavedNodeExistsSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingSavedNodeExistsSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingSavedNodeExistsSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingSavedNodeExistsSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingSavedNodeExistsSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingSavedNodeExistsSnapshot represents a SavedNodeExistsSnapshot event raised by the Staking contract.
type StakingSavedNodeExistsSnapshot struct {
	Client   common.Address
	NodeHash [32]byte
	Snapshot [32]byte
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterSavedNodeExistsSnapshot is a free log retrieval operation binding the contract event 0x98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556.
//
// Solidity: event SavedNodeExistsSnapshot(address client, bytes32 nodeHash, bytes32 snapshot)
func (_Staking *StakingFilterer) FilterSavedNodeExistsSnapshot(opts *bind.FilterOpts) (*StakingSavedNodeExistsSnapshotIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "SavedNodeExistsSnapshot")
	if err != nil {
		return nil, err
	}
	return &StakingSavedNodeExistsSnapshotIterator{contract: _Staking.contract, event: "SavedNodeExistsSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedNodeExistsSnapshot is a free log subscription operation binding the contract event 0x98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556.
//
// Solidity: event SavedNodeExistsSnapshot(address client, bytes32 nodeHash, bytes32 snapshot)
func (_Staking *StakingFilterer) WatchSavedNodeExistsSnapshot(opts *bind.WatchOpts, sink chan<- *StakingSavedNodeExistsSnapshot) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "SavedNodeExistsSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingSavedNodeExistsSnapshot)
				if err := _Staking.contract.UnpackLog(event, "SavedNodeExistsSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedNodeExistsSnapshot is a log parse operation binding the contract event 0x98c23aaa7c1edd19d6d64f4d7938f7b7286545e1cb67d19a6d4d500f75890556.
//
// Solidity: event SavedNodeExistsSnapshot(address client, bytes32 nodeHash, bytes32 snapshot)
func (_Staking *StakingFilterer) ParseSavedNodeExistsSnapshot(log types.Log) (*StakingSavedNodeExistsSnapshot, error) {
	event := new(StakingSavedNodeExistsSnapshot)
	if err := _Staking.contract.UnpackLog(event, "SavedNodeExistsSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// StakingSavedTwoStakersSnapshotIterator is returned from FilterSavedTwoStakersSnapshot and is used to iterate over the raw logs and unpacked data for SavedTwoStakersSnapshot events raised by the Staking contract.
type StakingSavedTwoStakersSnapshotIterator struct {
	Event *StakingSavedTwoStakersSnapshot // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *StakingSavedTwoStakersSnapshotIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(StakingSavedTwoStakersSnapshot)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(StakingSavedTwoStakersSnapshot)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *StakingSavedTwoStakersSnapshotIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *StakingSavedTwoStakersSnapshotIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// StakingSavedTwoStakersSnapshot represents a SavedTwoStakersSnapshot event raised by the Staking contract.
type StakingSavedTwoStakersSnapshot struct {
	Client    common.Address
	Addr1     common.Address
	Location1 [32]byte
	Addr2     common.Address
	Location2 [32]byte
	Snapshot  [32]byte
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterSavedTwoStakersSnapshot is a free log retrieval operation binding the contract event 0x18410fe1e6e0f23683d25f04192e6b95d64681eee6fc2abe5241d2f58cbfbe52.
//
// Solidity: event SavedTwoStakersSnapshot(address client, address addr1, bytes32 location1, address addr2, bytes32 location2, bytes32 snapshot)
func (_Staking *StakingFilterer) FilterSavedTwoStakersSnapshot(opts *bind.FilterOpts) (*StakingSavedTwoStakersSnapshotIterator, error) {

	logs, sub, err := _Staking.contract.FilterLogs(opts, "SavedTwoStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return &StakingSavedTwoStakersSnapshotIterator{contract: _Staking.contract, event: "SavedTwoStakersSnapshot", logs: logs, sub: sub}, nil
}

// WatchSavedTwoStakersSnapshot is a free log subscription operation binding the contract event 0x18410fe1e6e0f23683d25f04192e6b95d64681eee6fc2abe5241d2f58cbfbe52.
//
// Solidity: event SavedTwoStakersSnapshot(address client, address addr1, bytes32 location1, address addr2, bytes32 location2, bytes32 snapshot)
func (_Staking *StakingFilterer) WatchSavedTwoStakersSnapshot(opts *bind.WatchOpts, sink chan<- *StakingSavedTwoStakersSnapshot) (event.Subscription, error) {

	logs, sub, err := _Staking.contract.WatchLogs(opts, "SavedTwoStakersSnapshot")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(StakingSavedTwoStakersSnapshot)
				if err := _Staking.contract.UnpackLog(event, "SavedTwoStakersSnapshot", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSavedTwoStakersSnapshot is a log parse operation binding the contract event 0x18410fe1e6e0f23683d25f04192e6b95d64681eee6fc2abe5241d2f58cbfbe52.
//
// Solidity: event SavedTwoStakersSnapshot(address client, address addr1, bytes32 location1, address addr2, bytes32 location2, bytes32 snapshot)
func (_Staking *StakingFilterer) ParseSavedTwoStakersSnapshot(log types.Log) (*StakingSavedTwoStakersSnapshot, error) {
	event := new(StakingSavedTwoStakersSnapshot)
	if err := _Staking.contract.UnpackLog(event, "SavedTwoStakersSnapshot", log); err != nil {
		return nil, err
	}
	return event, nil
}

// VMABI is the input ABI used to generate the binding from.
const VMABI = "[]"

// VMBin is the compiled bytecode used for deploying new contracts.
var VMBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a72315820a39ecaa6ef96d769860af9c7cb91b33cf8eb0b35dc537a30cfb10fdc42e1fda564736f6c63430005100032"

// DeployVM deploys a new Ethereum contract, binding an instance of VM to it.
func DeployVM(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *VM, error) {
	parsed, err := abi.JSON(strings.NewReader(VMABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(VMBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &VM{VMCaller: VMCaller{contract: contract}, VMTransactor: VMTransactor{contract: contract}, VMFilterer: VMFilterer{contract: contract}}, nil
}

// VM is an auto generated Go binding around an Ethereum contract.
type VM struct {
	VMCaller     // Read-only binding to the contract
	VMTransactor // Write-only binding to the contract
	VMFilterer   // Log filterer for contract events
}

// VMCaller is an auto generated read-only Go binding around an Ethereum contract.
type VMCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// VMTransactor is an auto generated write-only Go binding around an Ethereum contract.
type VMTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// VMFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type VMFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// VMSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type VMSession struct {
	Contract     *VM               // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// VMCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type VMCallerSession struct {
	Contract *VMCaller     // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// VMTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type VMTransactorSession struct {
	Contract     *VMTransactor     // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// VMRaw is an auto generated low-level Go binding around an Ethereum contract.
type VMRaw struct {
	Contract *VM // Generic contract binding to access the raw methods on
}

// VMCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type VMCallerRaw struct {
	Contract *VMCaller // Generic read-only contract binding to access the raw methods on
}

// VMTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type VMTransactorRaw struct {
	Contract *VMTransactor // Generic write-only contract binding to access the raw methods on
}

// NewVM creates a new instance of VM, bound to a specific deployed contract.
func NewVM(address common.Address, backend bind.ContractBackend) (*VM, error) {
	contract, err := bindVM(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &VM{VMCaller: VMCaller{contract: contract}, VMTransactor: VMTransactor{contract: contract}, VMFilterer: VMFilterer{contract: contract}}, nil
}

// NewVMCaller creates a new read-only instance of VM, bound to a specific deployed contract.
func NewVMCaller(address common.Address, caller bind.ContractCaller) (*VMCaller, error) {
	contract, err := bindVM(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &VMCaller{contract: contract}, nil
}

// NewVMTransactor creates a new write-only instance of VM, bound to a specific deployed contract.
func NewVMTransactor(address common.Address, transactor bind.ContractTransactor) (*VMTransactor, error) {
	contract, err := bindVM(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &VMTransactor{contract: contract}, nil
}

// NewVMFilterer creates a new log filterer instance of VM, bound to a specific deployed contract.
func NewVMFilterer(address common.Address, filterer bind.ContractFilterer) (*VMFilterer, error) {
	contract, err := bindVM(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &VMFilterer{contract: contract}, nil
}

// bindVM binds a generic wrapper to an already deployed contract.
func bindVM(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(VMABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_VM *VMRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _VM.Contract.VMCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_VM *VMRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _VM.Contract.VMTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_VM *VMRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _VM.Contract.VMTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_VM *VMCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _VM.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_VM *VMTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _VM.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_VM *VMTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _VM.Contract.contract.Transact(opts, method, params...)
}

// ValueABI is the input ABI used to generate the binding from.
const ValueABI = "[]"

// ValueBin is the compiled bytecode used for deploying new contracts.
var ValueBin = "0x60556023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea265627a7a7231582000b6894369bfdc8a76e33bfadd7007d83e173eacf6823912ea6e40d1f59ae4ba64736f6c63430005100032"

// DeployValue deploys a new Ethereum contract, binding an instance of Value to it.
func DeployValue(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Value, error) {
	parsed, err := abi.JSON(strings.NewReader(ValueABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(ValueBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Value{ValueCaller: ValueCaller{contract: contract}, ValueTransactor: ValueTransactor{contract: contract}, ValueFilterer: ValueFilterer{contract: contract}}, nil
}

// Value is an auto generated Go binding around an Ethereum contract.
type Value struct {
	ValueCaller     // Read-only binding to the contract
	ValueTransactor // Write-only binding to the contract
	ValueFilterer   // Log filterer for contract events
}

// ValueCaller is an auto generated read-only Go binding around an Ethereum contract.
type ValueCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValueTransactor is an auto generated write-only Go binding around an Ethereum contract.
type ValueTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValueFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type ValueFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// ValueSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type ValueSession struct {
	Contract     *Value            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ValueCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type ValueCallerSession struct {
	Contract *ValueCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// ValueTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type ValueTransactorSession struct {
	Contract     *ValueTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// ValueRaw is an auto generated low-level Go binding around an Ethereum contract.
type ValueRaw struct {
	Contract *Value // Generic contract binding to access the raw methods on
}

// ValueCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type ValueCallerRaw struct {
	Contract *ValueCaller // Generic read-only contract binding to access the raw methods on
}

// ValueTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type ValueTransactorRaw struct {
	Contract *ValueTransactor // Generic write-only contract binding to access the raw methods on
}

// NewValue creates a new instance of Value, bound to a specific deployed contract.
func NewValue(address common.Address, backend bind.ContractBackend) (*Value, error) {
	contract, err := bindValue(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Value{ValueCaller: ValueCaller{contract: contract}, ValueTransactor: ValueTransactor{contract: contract}, ValueFilterer: ValueFilterer{contract: contract}}, nil
}

// NewValueCaller creates a new read-only instance of Value, bound to a specific deployed contract.
func NewValueCaller(address common.Address, caller bind.ContractCaller) (*ValueCaller, error) {
	contract, err := bindValue(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &ValueCaller{contract: contract}, nil
}

// NewValueTransactor creates a new write-only instance of Value, bound to a specific deployed contract.
func NewValueTransactor(address common.Address, transactor bind.ContractTransactor) (*ValueTransactor, error) {
	contract, err := bindValue(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &ValueTransactor{contract: contract}, nil
}

// NewValueFilterer creates a new log filterer instance of Value, bound to a specific deployed contract.
func NewValueFilterer(address common.Address, filterer bind.ContractFilterer) (*ValueFilterer, error) {
	contract, err := bindValue(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &ValueFilterer{contract: contract}, nil
}

// bindValue binds a generic wrapper to an already deployed contract.
func bindValue(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(ValueABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Value *ValueRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Value.Contract.ValueCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Value *ValueRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Value.Contract.ValueTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Value *ValueRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Value.Contract.ValueTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Value *ValueCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Value.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Value *ValueTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Value.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Value *ValueTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Value.Contract.contract.Transact(opts, method, params...)
}
